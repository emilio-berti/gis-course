[{"path":"index.html","id":"preface","chapter":"Preface","heading":"Preface","text":"started learning GIS 2017 PhD.\nprogramming know, learnt making many mistakes.\nstill make mistakes, means still learning.\naim course guide started learning GIS saved mistakes.\ncourse intended newcomers GIS; experienced users definitely look somewhere else (likely stackoverflow.com).course divided three main parts:General introduction GIS.Fundamentals GIS analysis.GIS analysis Google Earth Engine.","code":""},{"path":"index.html","id":"software-requirements","chapter":"Preface","heading":"Software requirements","text":"first part course, introduce basic concepts GIS using R Python.\n, use terra package R shapely module Python.\nfocus often R python.second part, cover fundamentals GIS analysis.\nexplain theory behind complement examples actual analyses, introducing common workflows R Python.\nuse R package terra Python modules shapely, geopandas, fiona, plotly.third part, focus Google Earth Engine explain move heavy GIS analyses cloud.\nrequire basic understanding JavaScript Python object-oriented programming, well interface GEE using gee Python module.\npart may seem redundant first (move computation Google servers?), , analyses expand scale need access several databases, GEE shines great trade-complexity effectiveness.install packages modules used book, can use conda environment management system.\nenvironment file https://github.com/emilio-berti/gis-course/blob/master/conda/gis-course.yml.","code":"conda env create --file=gis-course.yml"},{"path":"a-history-of-gis.html","id":"a-history-of-gis","chapter":"A history of GIS","heading":"A history of GIS","text":"Humans always interested mapping Earth.\nAnaximander among first publish map known world 6th century BC.\nFigure 0.1: Reconstruction map known world Anaximander.\n“Age Exploration”, accurate maps make difference riches starving sea, Tolkien-like style maps became realistic.\nFigure 0.2: portolan map Age Discovery.\nJump forward another 400 years many major technological advancements get Information Age, cartographic software started developed.\nGIS comprise hardware software collect, store, manage, analyze geographic data.\nToday, several GIS hardware software publicly accessible used many fields: urban planning, climate modeling, mining, warfare, etc.\nmay surprising ecologist, current GIS tools tightly linked mineral oil exploration, European Petroleum Survey Group (EPSG), warfare, GPS GLONASS.\nNevertheless, use GIS well-humanity stick biogeographic analyses.\nFigure 0.3: example map produced using QGIS, free GIS software.\n","code":""},{"path":"projections.html","id":"projections","chapter":"1 Projections","heading":"1 Projections","text":"map projection 2D representation Earth surface.\nseveral type projections, approximating Earth surface different ways.\nImportantly, spatial data must associated coordinate reference system (CRS), defines 2D map Earth surface related.\nGIS courses, CRS usually briefly discussed talked .\nHowever, CRS quite complicated topic one can introduce many errors analysis:\nchoose wrong CRS, calculations can extremely biased.give brief introduction CRS two reasons:complex topic going details takes long time.Honestly, still figuring obscure details CRS want say incorrect things.","code":""},{"path":"projections.html","id":"geographic-vs-projectes-crs","chapter":"1 Projections","heading":"1.1 Geographic vs Projectes CRS","text":"geographic CRS one locations points described longitude latitude, .e. angle Prime meridian (almost mythological creature) location angle Equator location, respectively.\nused geographic CRS WGS84 (EPSG:4326).projected CRS system represent 3D Earth surface plane.\nRepresenting 3D object 2D plane accurately possible.\nTherefore, projectons always distort property Earth surface, particular, least one : distance, angular conformity, area.\nProjections can grouped types, depending property Earth surface distort:Conformal projections: correctly represent angles points , thus, shapes. E.g., ESRI:54004 (Mercator).Equidistant: correctly represent distances. E.g., ESRI:54002.Equal-area: corretly represent areas. E.g. ESRI:54034.ESRI stands Environmental Systems Research Institute, Inc., company developed ArcGIS created code standard projections.\ncommonly used standard maintained European Petroleum Survey Group (EPSG).\ninstance, World Mercator (conformal) also EPSG:3395.common projected CRS Universal Transverse Mercator projection (conformal), e.g. EPSG:32632.\ntalk later chapter.\ncan find overview ESRI EPSG projections https://spatialreference.org/.\nWikipedia also nice list property projection: https://en.wikipedia.org/wiki/List_of_map_projections","code":""},{"path":"vectors.html","id":"vectors","chapter":"2 Vectors","heading":"2 Vectors","text":"Vectors (shapefiles) contain geospatial vector data, also called geometries.\nshapefile extension .shp usually accompanied files.\nCommon supplementary files :.shx = index geometries data model..dbf = attributes geometries table format..prj = WKT representation coordinate reference system.core concept shapefiles geographic features stored using three fundamental geometry types:Points, defined coordinates \\((x, y)\\).Lines, defined two points line interpolating .Polygons, defiend several lines.three fundamental types can also “stacked”, e.g. one spatial feature can represented multiple points, lines, polygons.\ncase, talk multipoints, multilines, multipolygons.\ndifference multilines polygons polygon inscribe area space, creates “inside” area “outside” one, multilines .","code":""},{"path":"vectors.html","id":"geometries-in-r","chapter":"2 Vectors","heading":"2.1 Geometries in R","text":"Let’s see exampled R using package terra.\nRemember load package already: library(terra).\nterra, hustle came older GIS software removed, geometries can simply created using vect() function.creates first geometry, point origin.\nmeaningful, however, must assign coordinate reference system geometry.\ncan done initialization .Geometries can converted types casting.\nterra made extremely easy.\nLet’s create points.cast lines using .lines().may want cast polygons, notice however lines inscribe area space, .e. “closed”.Trying cast lines polygons, return empty geometry.cast lines polygons, two points must identical.want cast points polygons, considered best practice first cast lines cast polygons (just ).\nTrying cast points polygons directly can introduce errors, works .geometry set properties.\nPoints coordinates:Lines length:polygons perimeter area:Note lines polygons also coordinates, breaking points straight lines, defined points:","code":"\nxy <- matrix(c(0, 0), ncol = 2)\npoi <- vect(xy)\ngeomtype(poi)## [1] \"points\"\npoi <- vect(xy, crs = \"EPSG:4326\")\npoi##  class       : SpatVector \n##  geometry    : points \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 0, 0, 0, 0  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)\nxy <- matrix(seq_len(10), ncol = 2)\npois <- vect(xy, crs = \"EPSG:4326\")\ngeomtype(pois)## [1] \"points\"\nls <- as.lines(pois)\ngeomtype(ls)## [1] \"lines\"\nplot(ls)\npoints(pois, cex = 2)\npol = as.polygons(ls)\ngeomtype(pol)## [1] \"none\"\nxy <- matrix(seq_len(10), ncol = 2)\nxy <- rbind(xy, cbind(5, 6)) #add bottom-right point\nxy <- rbind(xy, xy[1, ]) #add again first point\npois <- vect(xy, crs = \"EPSG:4326\")\nls <- as.lines(pois)\npol <- as.polygons(ls)\npol##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 1, 5, 6, 10  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)\n# show it\nplot(pol, col = \"dodgerblue\", alpha = .5)\nlines(ls, col = \"tomato\", lw = 3)\npoints(pois, cex = 3)\ngeom(pois)[, c(\"x\", \"y\")] #coordinates of points##      x  y\n## [1,] 1  6\n## [2,] 2  7\n## [3,] 3  8\n## [4,] 4  9\n## [5,] 5 10\n## [6,] 5  6\n## [7,] 1  6\nperim(ls) #length of line## [1] 1509805\nperim(pol) #perimeter of polygon## [1] 1509805\nexpanse(pol, unit = \"km\") #area of polygon## [1] 97586.03\ngeom(pol)##      geom part x  y hole\n## [1,]    1    1 1  6    0\n## [2,]    1    1 2  7    0\n## [3,]    1    1 3  8    0\n## [4,]    1    1 4  9    0\n## [5,]    1    1 5 10    0\n## [6,]    1    1 5  6    0\n## [7,]    1    1 1  6    0"},{"path":"vectors.html","id":"create-geometry-in-r-interactively","chapter":"2 Vectors","heading":"2.2 Create geometry in R interactively","text":"R terra nice feature allows draw plot save resulting geometry environment.\nachieved using function draw(), takes argument type geometry want draw (points, line, polygon, extent).just left-click map.\ndone, right click output saved variable drawing.useful want zoom region map draw coarse polygons don’t want open interactive GIS software, QGIS.","code":"\nplot(pol, col = \"dodgerblue3\", alpha = .5)\ndrawing = draw(\"lines\")"},{"path":"rasters.html","id":"rasters","chapter":"3 Rasters","heading":"3 Rasters","text":"rasters fundamentally 2D matrices matadata, useful understand matrix jumping straight topic.\n2D matrix \\(\\) mathematical object can represented grid.\nelements \\(A_{ij}\\) matrix \\(\\) called entries.\nsubscript \\(A_{ij}\\) indicate row column coordinates entries.\nexample, \\(A_{1,1}\\) element first row first column, \\(A_{3,4}\\) element third row fourth column.","code":""},{"path":"rasters.html","id":"matrices-in-r","chapter":"3 Rasters","heading":"3.1 Matrices in R","text":"R provides native support matrices.\nfact, R designed work matrices, statistical models can represented operation matrices.creating matrix, two import things often neglected.\nFirst, specifying byrow = TRUE, make sure values contained vals inserted matrix row-wise, .e. \\(A_{1,1}\\) = vals[1], \\(A_{1,2}\\) = vals[2], etc.\nargument can omitted inserting elements column-wise preferred; case, \\(A_{2,1}\\) = vals[2], etc..Second, least one ncol nrow specified, matrix one column (column vectors).\nspecify one two, R infer dimension.\ncan specify invite clarity, whenever possible.","code":"\nvals <- seq_len(9)\nA <- matrix(vals, byrow = TRUE, nrow = 3, ncol = 3)\nA##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9"},{"path":"rasters.html","id":"rasters-1","chapter":"3 Rasters","heading":"3.2 Rasters","text":"raster basically 2D matrix associated metadata.\nimportant metadata define:spatial extent.spatial resolution.coordinate reference system, crs.raster without three metadata , cases, useless.","code":""},{"path":"rasters.html","id":"rasters-in-r","chapter":"3 Rasters","heading":"3.3 Rasters in R","text":"R, terra provides need work rasters.\ncreate raster, can use rast() function.\ncan use input matrix.dataframe.rast() also used read rasters files.write rasters files, writeRaster() function used.overwrite datatype arguments optional, strongly recommend always include .\noverwrite = TRUE simply make sure , raster already exists disk, overwritten.\nterra, defaults, throw error file exists overwrite = FALSE, can annoying working servers.\ndatatype specifies numeric type matrix elements.\nAvailable types signed unsigned integer float.\nalso specify number bytes use entry.\nAvailable dataype choices :INT1U, unsigned integer 1 byte: \\(\\[0, 2^8]\\).INT2U, unsigned integer 2 bytes: \\(\\[0, 2^{16}]\\).INT2S, signed integer 2 bytes: \\(\\[-2^8 + 1, 2^8]\\).INT4U, unsigned integer 4 bytes: \\(\\[0, 2^{32}]\\).INT4S, signed integer 4 bytes: \\(\\[-2^{16} + 1, 2^{16}]\\).FLT4S, signed floating point (real) number 4 bytes: \\(\\[1.2 \\cdot 10^{-38}, 3.4 \\cdot 10^{38}]\\)FLT8S, signed floating point (real) number 8 bytes: \\(\\[2.3 \\cdot 10^{-308}, 1.7 \\cdot 10^{308}]\\)can actually store numbers also outside range numeric types, come cost precision, try avoid going outside ranges.\nmean always save files FLT8S, require disk space slow writing/reading operations.\nexample, want store elevation global scale precision one meter, INT2U optimal choice, smallest type can store information.","code":"\nr <- rast(A, crs = \"EPSG:4326\")\nr## class       : SpatRaster \n## dimensions  : 3, 3, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0, 3, 0, 3  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        : lyr.1 \n## min value   :     1 \n## max value   :     9\nd <- data.frame(\n  x = rep(seq_len(10), 10), #x coord\n  y = rep(seq_len(10), each = 10), #y coord\n  z = seq_len(100) #values\n)\nr <- rast(d, crs = \"EPSG:4326\")\nplot(r)\nr <- rast(\"some-file.tif\")\nwriteRaster(r, \"some-file.tif\", overwrite = TRUE, datatype = \"INT4U\")"},{"path":"rasters.html","id":"raster-manipulation","chapter":"3 Rasters","heading":"3.4 Raster manipulation","text":"Rasters can manipulated way matrix.\nexample:can also add multiply rasters together:","code":"\nr + 10 #add a constant## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :  11 \n## max value   : 110\n2 * r #multiply by a constant## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :   2 \n## max value   : 200\nr ^ 2 #power## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :     z \n## min value   :     1 \n## max value   : 10000\n2 * r + 10 #combined addition and multiplication## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :  12 \n## max value   : 210\nr + r## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :   2 \n## max value   : 200\nr * r## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :     z \n## min value   :     1 \n## max value   : 10000"},{"path":"rasters.html","id":"raster-stacks","chapter":"3 Rasters","heading":"3.5 Raster stacks","text":"can also stack rasters create 3D stacks.\nterra, achieved simply appending rasters together:Stacks quite useful can call vectorized functions , e.g.:","code":"\ns <- c(r, -r / 2)\ns## class       : SpatRaster \n## dimensions  : 10, 10, 2  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## names       :   z,     z \n## min values  :   1, -50.0 \n## max values  : 100,  -0.5\nplot(s)\nplot(mean(s)) #mean\nstdev(s)^2 #variance## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :       std \n## min value   :    0.5625 \n## max value   : 5625.0000\nprod(s) #product## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   prod \n## min value   : -5e+03 \n## max value   : -5e-01"},{"path":"rasters.html","id":"example-stacks-for-ecology","chapter":"3 Rasters","heading":"3.6 Example: stacks for ecology","text":"Imagine sampled occurrences 100 species want know number species detected cell.\ndistribution one species saved file species-1.tif may look like :can load :get number species detected cell, simply need sum across stack:","code":"\nr <- rast(\"species-1.tif\")\nplot(r)\nfiles <- list.files(\"data/\", pattern = \"species-\")\ns <- rast(files)\nplot(s[[c(5, 35, 75)]]) #show species 5, 35, and 75\nS <- sum(s)\nplot(S, col = hcl.colors(minmax(S)[\"max\", ] + 1, \"Zissou 1\"))"},{"path":"overview-of-the-data-we-will-use.html","id":"overview-of-the-data-we-will-use","chapter":"4 Overview of the data we will use","heading":"4 Overview of the data we will use","text":"operations staple GIS.\nexample: distance two features? area polygon? value raster specific locations?\nillustrate practical examples, use data can find data/ folder repo https://github.com/emilio-berti/gis-course.data/EU/EU.shp contains polygons countries European Union:data/ISTAT/Limiti01012024_g/Reg01012024_g/Reg01012024_g_WGS84.shp contains polygons regions (administrative division state) Italy:data/ISTAT/Limiti01012024_g/ProvCM01012024_g/ProvCM01012024_g_WGS84.shp contains polygons provinces (administrative division commune region) Italy:data/wc2.1_10m_bio_1.tif mean annual temperature (averaged across several decades) 10 minute resolution WorldClim. cropped Europe (excluding parts Scandinavia save disk space):","code":"\neu <- vect(\"data/EU/EU.shp\")\nplot(eu, col = \"#001489\", border = \"white\", lw = 2)\nreg <- vect(\"data/ISTAT/Limiti01012024_g/Reg01012024_g/Reg01012024_g_WGS84.shp\")\nplot(reg, \"DEN_REG\", col = hcl.colors(length(reg), \"Set 2\"))\nitaly <- vect(\"data/ISTAT/Limiti01012024_g/ProvCM01012024_g/ProvCM01012024_g_WGS84.shp\")\nplot(italy, \"DEN_UTS\", col = colors()[sample(seq_along(colors()), length(italy))])\nbio1 <- rast(\"data/wc2.1_10m_bio_1.tif\")\nplot(bio1, col = hcl.colors(100, \"Zissou 1\"))"},{"path":"convert-a-vector-to-a-raster.html","id":"convert-a-vector-to-a-raster","chapter":"5 Convert a vector to a raster","heading":"5 Convert a vector to a raster","text":"terra, vector can converted raster using rasterize(x, y),\nx vector convert raster y template raster metadata re-used x:rasterize() can also take optional argument field, used assign cells values:","code":"\nbio1 <- rast(\"data/wc2.1_10m_bio_1.tif\") #load raster template\neu <- vect(\"data/EU/EU.shp\") #load zone layer\nr_eu <- rasterize(eu, bio1)\nplot(r_eu, col = \"#001489\")\nr_eu <- rasterize(eu, bio1, field = \"NAME_ENGL\")\nplot(r_eu, col = hcl.colors(length(eu), \"Dynamic\"))\nlines(eu)"},{"path":"convert-a-vector-to-a-raster.html","id":"covert-a-raster-to-a-vector","chapter":"5 Convert a vector to a raster","heading":"5.1 Covert a raster to a vector","text":".polygons() can used convert raster vector.\ndefault, new polygon dissolved, .e. vector one geometry value raster; can turned specifying dissolve = FALSE, usually want dissolved.\nMoreover, default behavior .polygons() round rasters many different values, avoid creating many polygons; can turned specifying round = FALSE.\nLet’s look options:","code":"\n#default is round = TRUE an dissolve = TRUE\nlength(as.polygons(bio1, round = FALSE))## [1] 40477\nlength(as.polygons(bio1, dissolve = FALSE))## [1] 40856\nlength(as.polygons(bio1, round = FALSE, dissolve = FALSE))## [1] 40856\nv_bio1 <- as.polygons(bio1) \nlength(v_bio1)## [1] 30\nplot(v_bio1, col = hcl.colors(length(v_bio1), \"Zissou 1\"))"},{"path":"simple-operations-on-vectors.html","id":"simple-operations-on-vectors","chapter":"6 Simple operations on vectors","heading":"6 Simple operations on vectors","text":"","code":""},{"path":"simple-operations-on-vectors.html","id":"perimiter","chapter":"6 Simple operations on vectors","heading":"6.1 Perimiter","text":"perim() used get perimiter vector:(Look Greece islands!)","code":"\neu <- vect(\"data/EU/EU.shp\")\neu[[\"perimeter\"]] <- perim(eu) / 1e3 #in km - assigned as an attribute of vector\nplot(eu, \"perimeter\", type = \"continuous\", col = hcl.colors(length(eu), \"Dark Mint\"))"},{"path":"simple-operations-on-vectors.html","id":"area","chapter":"6 Simple operations on vectors","heading":"6.2 Area","text":"expanse() used calculate area vectors:(Sweden smaller looks)Bonus:(call relationship island factor)","code":"\neu[[\"area\"]] <- expanse(eu, unit = \"km\")\nplot(eu, \"area\", type = \"continuous\", col = hcl.colors(length(eu), \"Dark Mint\"))\nmapped_islands <- table(disagg(eu)$NAME_ENGL)[eu$NAME_ENGL] #some magic\nwith(as.data.frame(eu), plot(\n  perimeter, area, \n  pch = 20, cex = 2,\n  col = \"dodgerblue3\"\n))\ntext(\n  x = eu$perimeter, y = eu$area,\n  labels = eu$NAME_ENGL, \n  adj = c(0.5, -1),\n)\ntext(\n  x = eu$perimeter, y = eu$area,\n  labels = paste(mapped_islands, \"islands\"),\n  adj = c(0.5, 2),\n)"},{"path":"simple-operations-on-vectors.html","id":"centroids","chapter":"6 Simple operations on vectors","heading":"6.3 Centroids","text":"centroid point defined arithmetic mean position points surface polygon.\ninstance, centroids square polygon ’s center:","code":"\np <- vect(matrix(c(0, 0, 1, 0, 1, 1, 0, 1, 0, 0), byrow = TRUE, ncol = 2))\np <- as.lines(p)\np <- as.polygons(p)\ncentr <- centroids(p)\nplot(p, col = \"dodgerblue\", alpha = .5)\npoints(centr, col = \"tomato\", cex = 3)\np <- vect(matrix(c(0, 0, 1, 0, 1, 1, 0.9, 0.1, 0, 0), byrow = TRUE, ncol = 2))\np <- as.lines(p)\np <- as.polygons(p)\ncentr <- centroids(p)\nplot(p, col = \"dodgerblue\", alpha = .5)\npoints(centr, col = \"tomato\", cex = 3)\neu_centr <- centroids(eu)\neu <- vect(\"data/EU/EU.shp\")\nplot(eu, col = \"#001489\", border = \"white\", lw = 1)\npoints(eu_centr, col = \"#FFDD00\", cex = 2, pch = 3, lw = 2)"},{"path":"simple-operations-on-vectors.html","id":"buffer","chapter":"6 Simple operations on vectors","heading":"6.4 Buffer","text":"buffer polygon extend perimeter directions time, .e. orthogonally tangent line point.\nBuffering achieved terra using buffer(x, width).\neasier see explain .","code":"\nb <- buffer(eu, 1e5) #100km for visualizing it\nplot(eu, col = \"#001489\")\nlines(b, col = \"tomato\", lw = 2)"},{"path":"simple-operations-on-vectors.html","id":"neighbors-of-polygons","chapter":"6 Simple operations on vectors","heading":"6.5 Neighbors of polygons","text":"terra, neighbors polygon obtained using adjacent().\noutput adjacent() matrix, either two columns first IDs \\(n\\) countries \\(n \\times n\\) representing adjacency matrix countries.\nlike adjacency matrix, therefore:","code":"\nneigh <- as.list(rep(NA, length(eu))) #initialize empty list\nnames(neigh) <- eu$NAME_ENGL\nadj <- adjacent(eu, pairs = FALSE)\nfor (i in seq_along(eu)) {\n  ctr <- eu[adj[i, ] == 1, ]\n  if(length(ctr) > 0) {\n    neigh[[i]] <- unique(ctr$NAME_ENGL)\n  } else {\n    neigh[[i]] <- \"No neighbours\"\n  }\n}\neu$neigh <- sapply(neigh, length)\neu$neigh[sapply(neigh, \\(x) all(x == \"No neighbours\"))] <- 0\nplot(eu, \"neigh\", col = hcl.colors(max(eu$neigh) + 1, \"Dark Mint\"))"},{"path":"vector-operations.html","id":"vector-operations","chapter":"7 Vector operations","heading":"7 Vector operations","text":"","code":""},{"path":"vector-operations.html","id":"loading-vectors","chapter":"7 Vector operations","heading":"7.1 Loading vectors","text":"Load vector shapefile EU countries:vector contains polygons 27 countries European Union (EU).\nAdditionally, attribute table attached , providing information country name, ISO3 code, etc.\ncan see full list attributes using names(eu):","code":"\neu <- vect(\"data/EU/EU.shp\")\neu##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 27, 11  (geometries, attributes)\n##  extent      : -10.38743, 34.39352, 34.57181, 70.0864  (xmin, xmax, ymin, ymax)\n##  source      : EU.shp\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326) \n##  names       : CNTR_ID NAME_ENGL NAME_FREN ISO3_CODE         SVRG_UN     CAPT\n##  type        :   <chr>     <chr>     <chr>     <chr>           <chr>    <chr>\n##  values      :      AT   Austria  Autriche       AUT UN Member State   Vienna\n##                     BE   Belgium  Belgique       BEL UN Member State Brussels\n##                     BG  Bulgaria  Bulgarie       BGR UN Member State    Sofia\n##  EU_STAT EFTA_STAT CC_STAT  NAME_GERM   FID\n##    <chr>     <chr>   <chr>      <chr> <chr>\n##        T         F       F Österreich    AT\n##        T         F       F    Belgien    BE\n##        T         F       F  Bulgarien    BG\nnames(eu)##  [1] \"CNTR_ID\"   \"NAME_ENGL\" \"NAME_FREN\" \"ISO3_CODE\" \"SVRG_UN\"   \"CAPT\"     \n##  [7] \"EU_STAT\"   \"EFTA_STAT\" \"CC_STAT\"   \"NAME_GERM\" \"FID\""},{"path":"vector-operations.html","id":"plotting-vectors","chapter":"7 Vector operations","heading":"7.2 Plotting vectors","text":"Let’s put map:familiar maps, may recognize longitude-latitude projection: axes represent arc-degrees.\nsure, check CRS vector:expected, longlat CRS.\nargument proj = TRUE specifies want PROJ-string output.\nreadable standard output terra:cases, instance calculating areas polygons, longlat CRS recommended.","code":"\nplot(eu, col = \"dodgerblue\")\nnorth() #show the North\nsbar(1e3, type = \"bar\", divs = 4, below = \"kilometers\", xy = c(-10, 60)) #show a scale bar\ncrs(eu, proj = TRUE)## [1] \"+proj=longlat +datum=WGS84 +no_defs\"\ncrs(eu, proj = FALSE)## [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\""},{"path":"vector-operations.html","id":"area-extent","chapter":"7 Vector operations","heading":"7.3 Area extent","text":"terra, function expanse() calculate areas.\nread documentation, also specified longlat CRS accurate calculate areas.\nLet’s calcualte area country add attribute table vector:can now make map polygons filled colors representing county area:reason identical country close 1km less another also adjacent neighbor.","code":"\nA <- expanse(eu, unit = \"km\")\neu$area <- A\neu[, c(\"NAME_ENGL\", \"area\")]##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 27, 2  (geometries, attributes)\n##  extent      : -10.38743, 34.39352, 34.57181, 70.0864  (xmin, xmax, ymin, ymax)\n##  source      : EU.shp\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326) \n##  names       : NAME_ENGL      area\n##  type        :     <chr>     <num>\n##  values      :   Austria 8.386e+04\n##                  Belgium  3.07e+04\n##                 Bulgaria 1.111e+05\n# a gradient palette with number of colors = countries\npal <- colorRampPalette(c(\"grey80\", \"tomato3\", \"tomato\"))(nrow(eu))\npal <- rev(pal[order(eu$area)]) #arrange colors\nplot(eu, col = pal) #adding a legend to vector maps is not easy and will leave it for another chapter.\nnorth()\nsbar(1e3, type = \"bar\", divs = 4, below = \"kilometers\", xy = c(-10, 60)) "},{"path":"zonal-statistics.html","id":"zonal-statistics","chapter":"8 Zonal statistics","heading":"8 Zonal statistics","text":"Zonal statstics calcualted zones, .e. regions defined either cell value (rasters) polygons (shapefiles).\nZonal calculation implemented terra using zonal().","code":""},{"path":"zonal-statistics.html","id":"zones-as-a-shapefile","chapter":"8 Zonal statistics","heading":"8.1 Zones as a shapefile","text":"zones defined shapefile, e.g. polygons EU, zonal statistics calculated.\nsyntax zonal(x, y, fun),\nx layer values calculate statistics ,\ny layer zones,\nfun function statistic.\nexample, can calculate average value annual temperature coutry see varies latitude:\ncase x raster (usually ), can also geometry.using another fun can obtain statistics.\nexample, can get minimum maximum values country:","code":"\neu <- vect(\"data/EU/EU.shp\") #load zone layer\neu_centr <- centroids(eu) #get centroids\nlat <- geom(eu_centr)[, \"y\"] #get latitude of centroids\n\nbio1 <- rast(\"data/wc2.1_10m_bio_1.tif\") #load temperature layer\n\nbio1_mean <- zonal(bio1, eu, \"mean\") #zonal calculation - mean value\nbio1_mean <- bio1_mean[[1]] #as vector\nplot(\n  lat, bio1_mean,\n  pch = 20, cex = 2, \n  col = \"grey50\",\n  xlab = \"Latitude\",\n  ylab = \"Average temperature\"\n)\nbio1_min <- zonal(bio1, eu, \"min\") #zonal calculation\nbio1_min <- bio1_min[[1]] #as vector\nbio1_max <- zonal(bio1, eu, \"max\") #zonal calculation\nbio1_max <- bio1_max[[1]] #as vector\nplot(\n  lat, bio1_mean,\n  pch = 20, cex = 2, \n  col = \"grey50\",\n  xlab = \"Latitude\",\n  ylab = \"Average temperature\",\n  ylim = c(min(bio1_min), max(bio1_max))\n)\npoints(\n  lat, bio1_min,\n  pch = 6, cex = 2, \n  col = \"dodgerblue3\"\n)\npoints(\n  lat, bio1_max,\n  pch = 2, cex = 2, \n  col = \"tomato\"\n)"},{"path":"mapping.html","id":"mapping","chapter":"9 Mapping","heading":"9 Mapping","text":"One common goal GIS produce map phenomenon process.example, use data Italian National Insitute Statistics (ISTAT):Administrative division shapefile (https://www.istat.//archivio/222527).GDP regions, second administrative division State.data/ISTAT/ folder, respective subdirectories.Load vector shapefile EU countries:","code":"\nlibrary(terra)\n\n# shapefile of regions\nregs <- vect(\"data/ISTAT/Limiti01012024_g/Reg01012024_g/Reg01012024_g_WGS84.shp\")\n\n# shapefile of cities\ncities <- vect(\"data/ISTAT/Limiti01012024_g/Com01012024_g/Com01012024_g_WGS84.shp\")\n\n# noise pollution\nnoise <- read.csv(\"data/ISTAT/city-acoustic-noise.csv\")\nnoise <- noise[noise$TIME_PERIOD == 2012, ] #only 2012\nnoise <- noise[noise$TIME_PERIOD != \"IT\", ] #only city level\nnoise <- noise[noise$TYPE_OF_MONITORING == 1, ] #sensor type\nnoise <- noise[!is.na(noise$OBS_VALUE), ] #remove empty\nnoise <- noise[noise$DATA_TYPE == \"MON_LIM\", ] #monthly limit\n\n# not all cities studies: remove not studied\nstudied <- intersect(cities$PRO_COM_T, noise$REF_AREA)\ncities <- cities[cities$PRO_COM_T %in% studied]\nnoise <- noise[noise$REF_AREA %in% studied, ]\n\n# add attribute\ncities$noise <- noise$OBS_VALUE[sapply(noise$REF_AREA, \\(x) which(cities$PRO_COM_T == x))]\ncities <- cities[order(cities$noise)]\ncities <- cities[cities$noise > 0] #suspect data\n\n# map -----------\nnoise_vals <- unique(cities$noise)\ncolors <- colorRampPalette(c(\"green3\", \"tomato\"))(length(noise_vals))\npal <- c()\nfor ( x in noise_vals ) {\n  pal <- c(pal, rep(colors[which(x == noise_vals)], sum(cities$noise == x)))\n}\n\n#plot(regs)\n#plot(cities, col = as.numeric(cities$noise), add = TRUE)\n\n# regional statistics ----------\nregs$noise <- NA\nregs$noise_cv <- NA\nfor ( i in seq_along(regs) ) {\n  within <- relate(cities, regs[i], \"within\")\n  ids <- which(within, arr.ind = TRUE)[, \"row\"]\n  regs$noise[ids] <- mean(cities$noise[ids])\n  regs$noise_cv[ids] <-  sd(cities$noise[ids]) / mean(cities$noise[ids])\n}\nregs$noise <- as.numeric(regs$noise)\nregs$noise_cv <- as.numeric(regs$noise_cv)\n\nlayout(matrix(c(2, 3, 1, 1), byrow = TRUE, ncol = 2))\npar(mar = c(4, 4, 2, 2))\nscatter.smooth(\n  regs$noise, regs$noise_cv,\n  pch = 20, cex = 2, frame = FALSE,\n  xlab = \"Noise\",\n  ylab = \"Variability (CV)\"\n)\nplot(\n  regs,\n  \"noise\",\n  col = colorRampPalette(c(\"green2\", \"tomato\"))(20),\n  type = \"continuous\",\n  axes = FALSE,\n  main = \"Noise pollution\"\n)\nplot(\n  regs,\n  \"noise_cv\",\n  col = colorRampPalette(c(\"grey90\", \"dodgerblue2\"))(20),\n  type = \"continuous\",\n  axes = FALSE,\n  main = \"Variability (CV)\"\n)"}]
