[{"path":"index.html","id":"preface","chapter":"Preface","heading":"Preface","text":"started learning GIS 2017 PhD.\nprogramming know, learnt making many mistakes.\nstill make mistakes, means still learning.\naim course guide started learning GIS saved mistakes.\ncourse intended newcomers GIS; experienced users definitely look somewhere else (likely stackoverflow.com).course divided three main parts:General introduction GIS.Fundamentals GIS analysis.GIS analysis Google Earth Engine.","code":""},{"path":"index.html","id":"software-requirements","chapter":"Preface","heading":"Software requirements","text":"first part course, introduce basic concepts GIS using R Python.\n, use terra package R shapely module Python.\nfocus often R python.second part, cover fundamentals GIS analysis.\nexplain theory behind complement examples actual analyses, introducing common workflows R Python.\nuse R package terra Python modules shapely, geopandas, fiona, plotly.third part, focus Google Earth Engine explain move heavy GIS analyses cloud.\nrequire basic understanding JavaScript Python object-oriented programming, well interface GEE using gee Python module.\npart may seem redundant first (move computation Google servers?), , analyses expand scale need access several databases, GEE shines great trade-complexity effectiveness.install packages modules used book, can use conda environment management system.\nenvironment file https://github.com/emilio-berti/gis-course/blob/master/conda/gis-course.yml.","code":"conda env create --file=gis-course.yml"},{"path":"a-history-of-gis.html","id":"a-history-of-gis","chapter":"A history of GIS","heading":"A history of GIS","text":"Humans always interested mapping Earth.\nAnaximander among first publish map known world 6th century BC.\nFigure 0.1: Reconstruction map known world Anaximander.\n“Age Exploration”, accurate maps make difference riches starving sea, Tolkien-like style maps became realistic.\nFigure 0.2: portolan map Age Discovery.\nJump forward another 400 years many major technological advancements get Information Age, cartographic software started developed.\nGIS comprise hardware software collect, store, manage, analyze geographic data.\nToday, several GIS hardware software publicly accessible used many fields: urban planning, climate modeling, mining, warfare, etc.\nmay surprising ecologist, current GIS tools tightly linked mineral oil exploration, European Petroleum Survey Group (EPSG), warfare, GPS GLONASS.\nNevertheless, use GIS well-humanity stick biogeographic analyses.\nFigure 0.3: example map produced using QGIS, free GIS software.\n","code":""},{"path":"projections.html","id":"projections","chapter":"1 Projections","heading":"1 Projections","text":"map projection 2D representation Earth surface.\nseveral type projections, approximating Earth surface different ways.\nImportantly, spatial data must associated coordinate reference system (CRS), defines 2D map Earth surface related.\nGIS courses, CRS usually briefly discussed talked .\nHowever, CRS quite complicated topic one can introduce many errors analysis:\nchoose wrong CRS, calculations can extremely biased.give brief introduction CRS two reasons:complex topic going details takes long time.Honestly, still figuring obscure details CRS want say incorrect things.","code":""},{"path":"projections.html","id":"geographic-vs-projectes-crs","chapter":"1 Projections","heading":"1.1 Geographic vs Projectes CRS","text":"geographic CRS one locations points described longitude latitude, .e. angle Prime meridian (almost mythological creature) location angle Equator location, respectively.\nused geographic CRS WGS84 (EPSG:4326).projected CRS system represent 3D Earth surface plane.\nRepresenting 3D object 2D plane accurately possible.\nTherefore, projectons always distort property Earth surface, particular, least one : distance, angular conformity, area.\nProjections can grouped types, depending property Earth surface distort:Conformal projections: correctly represent angles points , thus, shapes. E.g., ESRI:54004 (Mercator).Equidistant: correctly represent distances. E.g., ESRI:54002.Equal-area: corretly represent areas. E.g. ESRI:54034.ESRI stands Environmental Systems Research Institute, Inc., company developed ArcGIS created code standard projections.\ncommonly used standard maintained European Petroleum Survey Group (EPSG).\ninstance, World Mercator (conformal) also EPSG:3395.common projected CRS Universal Transverse Mercator projection (conformal), e.g. EPSG:32632.\ntalk later chapter.\ncan find overview ESRI EPSG projections https://spatialreference.org/.\nWikipedia also nice list property projection: https://en.wikipedia.org/wiki/List_of_map_projections","code":""},{"path":"shapefiles.html","id":"shapefiles","chapter":"2 Shapefiles","heading":"2 Shapefiles","text":"Shapefiles contain geospatial vector data, also called geometries.\nshapefile extension .shp usually accompanied files.\nCommon supplementary files :.shx = index geometries data model..dbf = attributes geometries table format..prj = WKT representation coordinate reference system.core concept shapefiles geographic features stored using three fundamental geometry types:Points, defined coordinates \\((x, y)\\).Lines, defined two points line interpolating .Polygons, defiend several lines.three fundamental types can also “stacked”, e.g. one spatial feature can represented multiple points, lines, polygons.\ncase, talk multipoints, multilines, multipolygons.\ndifference multilines polygons polygon inscribe area space, creates “inside” area “outside” one, multilines .","code":""},{"path":"shapefiles.html","id":"geometries-in-r","chapter":"2 Shapefiles","heading":"2.1 Geometries in R","text":"Let’s see exampled R using package terra.\nRemember load package already: library(terra).\nterra, hustle came older GIS software removed, geometries can simply created using vect() function.creates first geometry, point origin.\nmeaningful, however, must assign coordinate reference system geometry.\ncan done initialization .Geometries can converted types casting.\nterra made extremely easy.\nLet’s create points.cast lines using .lines().may want cast polygons, notice however lines inscribe area space, .e. “closed”.Trying cast lines polygons, return empty geometry.cast lines polygons, two points must identical.want cast points polygons, considered best practice first cast lines cast polygons (just ).\nTrying cast points polygons directly can introduce errors, works .geometry set properties.\nPoints coordinates:Lines length:polygons perimeter area:Note lines polygons also coordinates, breaking points straight lines, defined points:","code":"\nxy <- matrix(c(0, 0), ncol = 2)\npoi <- vect(xy)\ngeomtype(poi)## [1] \"points\"\npoi <- vect(xy, crs = \"EPSG:4326\")\npoi##  class       : SpatVector \n##  geometry    : points \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 0, 0, 0, 0  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)\nxy <- matrix(seq_len(10), ncol = 2)\npois <- vect(xy, crs = \"EPSG:4326\")\ngeomtype(pois)## [1] \"points\"\nls <- as.lines(pois)\ngeomtype(ls)## [1] \"lines\"\nplot(ls)\npoints(pois, cex = 2)\npol = as.polygons(ls)\ngeomtype(pol)## [1] \"none\"\nxy <- matrix(seq_len(10), ncol = 2)\nxy <- rbind(xy, cbind(5, 6)) #add bottom-right point\nxy <- rbind(xy, xy[1, ]) #add again first point\npois <- vect(xy, crs = \"EPSG:4326\")\nls <- as.lines(pois)\npol <- as.polygons(ls)\npol##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 1, 5, 6, 10  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)\n# show it\nplot(pol, col = \"dodgerblue\", alpha = .5)\nlines(ls, col = \"tomato\", lw = 3)\npoints(pois, cex = 3)\ngeom(pois)[, c(\"x\", \"y\")] #coordinates of points##      x  y\n## [1,] 1  6\n## [2,] 2  7\n## [3,] 3  8\n## [4,] 4  9\n## [5,] 5 10\n## [6,] 5  6\n## [7,] 1  6\nperim(ls) #length of line## [1] 1509805\nperim(pol) #perimeter of polygon## [1] 1509805\nexpanse(pol, unit = \"km\") #area of polygon## [1] 97586.03\ngeom(pol)##      geom part x  y hole\n## [1,]    1    1 1  6    0\n## [2,]    1    1 2  7    0\n## [3,]    1    1 3  8    0\n## [4,]    1    1 4  9    0\n## [5,]    1    1 5 10    0\n## [6,]    1    1 5  6    0\n## [7,]    1    1 1  6    0"},{"path":"shapefiles.html","id":"create-geometry-in-r-interactively","chapter":"2 Shapefiles","heading":"2.2 Create geometry in R interactively","text":"R terra nice feature allows draw plot save resulting geometry environment.\nachieved using function draw(), takes argument type geometry want draw (points, line, polygon, extent).just left-click map.\ndone, right click output saved variable drawing.Example drawing line using terra draw().useful want zoom region map draw coarse polygons, don’t want open interactive GIS software, QGIS.","code":"plot(pol, col = \"dodgerblue3\", alpha = .5)\n_drawing = draw(\"lines\")"},{"path":"rasters.html","id":"rasters","chapter":"3 Rasters","heading":"3 Rasters","text":"rasters fundamentally 2D matrices matadata, useful understand matrix jumping straight topic.\n2D matrix \\(\\) mathematical object can represented grid.\nelements \\(A_{ij}\\) matrix \\(\\) called entries.\nsubscript \\(A_{ij}\\) indicate row column coordinates entries.\nexample, \\(A_{1,1}\\) element first row first column, \\(A_{3,4}\\) element third row fourth column.","code":""},{"path":"rasters.html","id":"matrices-in-r","chapter":"3 Rasters","heading":"3.1 Matrices in R","text":"R provides native support matrices.\nfact, R designed work matrices, statistical models can represented operation matrices.creating matrix, two import things often neglected.\nFirst, specifying byrow = TRUE, make sure values contained vals inserted matrix row-wise, .e. \\(A_{1,1}\\) = vals[1], \\(A_{1,2}\\) = vals[2], etc.\nargument can omitted inserting elements column-wise preferred; case, \\(A_{2,1}\\) = vals[2], etc..Second, least one ncol nrow specified, matrix one column (column vectors).\nspecify one two, R infer dimension.\ncan specify invite clarity, whenever possible.","code":"\nvals <- seq_len(9)\nA <- matrix(vals, byrow = TRUE, nrow = 3, ncol = 3)\nA##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9"},{"path":"rasters.html","id":"rasters-1","chapter":"3 Rasters","heading":"3.2 Rasters","text":"raster basically 2D matrix associated metadata.\nimportant metadata define:spatial extent.spatial resolution.coordinate reference system, crs.raster without three metadata , cases, useless.","code":""},{"path":"rasters.html","id":"rasters-in-r","chapter":"3 Rasters","heading":"3.3 Rasters in R","text":"R, terra provides need work rasters.\ncreate raster, can use rast() function.\ncan use input matrix.dataframe.rast() also used read rasters files.write rasters files, writeRaster() function used.overwrite datatype arguments optional, strongly recommend always include .\noverwrite = TRUE simply make sure , raster already exists disk, overwritten.\nterra, defaults, throw error file exists overwrite = FALSE, can annoying working servers.\ndatatype specifies numeric type matrix elements.\nAvailable types signed unsigned integer float.\nalso specify number bytes use entry.\nAvailable dataype choices :INT1U, unsigned integer 1 byte: \\(\\[0, 2^8]\\).INT2U, unsigned integer 2 bytes: \\(\\[0, 2^{16}]\\).INT2S, signed integer 2 bytes: \\(\\[-2^8 + 1, 2^8]\\).INT4U, unsigned integer 4 bytes: \\(\\[0, 2^{32}]\\).INT4S, signed integer 4 bytes: \\(\\[-2^{16} + 1, 2^{16}]\\).FLT4S, signed floating point (real) number 4 bytes: \\(\\[1.2 \\cdot 10^{-38}, 3.4 \\cdot 10^{38}]\\)FLT8S, signed floating point (real) number 8 bytes: \\(\\[2.3 \\cdot 10^{-308}, 1.7 \\cdot 10^{308}]\\)can actually store numbers also outside range numeric types, come cost precision, try avoid going outside ranges.\nmean always save files FLT8S, require disk space slow writing/reading operations.\nexample, want store elevation global scale precision one meter, INT2U optimal choice, smallest type can store information.","code":"\nr <- rast(A, crs = \"EPSG:4326\")\nr## class       : SpatRaster \n## dimensions  : 3, 3, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0, 3, 0, 3  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        : lyr.1 \n## min value   :     1 \n## max value   :     9\nd <- data.frame(\n  x = rep(seq_len(10), 10), #x coord\n  y = rep(seq_len(10), each = 10), #y coord\n  z = seq_len(100) #values\n)\nr <- rast(d, crs = \"EPSG:4326\")\nplot(r)\nr <- rast(\"some-file.tif\")\nwriteRaster(r, \"some-file.tif\", overwrite = TRUE, datatype = \"INT4U\")"},{"path":"rasters.html","id":"raster-manipulation","chapter":"3 Rasters","heading":"3.4 Raster manipulation","text":"Rasters can manipulated way matrix.\nexample:can also add multiply rasters together:","code":"\nr + 10 #add a constant## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :  11 \n## max value   : 110\n2 * r #multiply by a constant## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :   2 \n## max value   : 200\nr ^ 2 #power## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :     z \n## min value   :     1 \n## max value   : 10000\n2 * r + 10 #combined addition and multiplication## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :  12 \n## max value   : 210\nr + r## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :   2 \n## max value   : 200\nr * r## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :     z \n## min value   :     1 \n## max value   : 10000"},{"path":"rasters.html","id":"raster-stacks","chapter":"3 Rasters","heading":"3.5 Raster stacks","text":"can also stack rasters create 3D stacks.\nterra, achieved simply appending rasters together:Stacks quite useful can call vectorized functions , e.g.:","code":"\ns <- c(r, -r / 2)\ns## class       : SpatRaster \n## dimensions  : 10, 10, 2  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## names       :   z,     z \n## min values  :   1, -50.0 \n## max values  : 100,  -0.5\nplot(s)\nplot(mean(s)) #mean\nstdev(s)^2 #variance## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :       std \n## min value   :    0.5625 \n## max value   : 5625.0000\nprod(s) #product## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   prod \n## min value   : -5e+03 \n## max value   : -5e-01"},{"path":"rasters.html","id":"example-stacks-for-ecology","chapter":"3 Rasters","heading":"3.6 Example: stacks for ecology","text":"Imagine sampled occurrences 100 species want know number species detected cell.\ndistribution one species saved file species-1.tif may look like :can load :get number species detected cell, simply need sum across stack:","code":"\nr <- rast(\"species-1.tif\")\nplot(r)\nfiles <- list.files(\"data/\", pattern = \"species-\")\ns <- rast(files)\nplot(s[[c(5, 35, 75)]]) #show species 5, 35, and 75\nS <- sum(s)\nplot(S, col = hcl.colors(minmax(S)[\"max\", ], \"Zissou 1\"))"},{"path":"basic-operations.html","id":"basic-operations","chapter":"4 Basic Operations","heading":"4 Basic Operations","text":"operations staple GIS.\nexample: distance two features? area polygon? value raster specific locations?GitHub repository, put data folder contains data can use.","code":""},{"path":"vector-operations.html","id":"vector-operations","chapter":"5 Vector operations","heading":"5 Vector operations","text":"","code":""},{"path":"vector-operations.html","id":"loading-vectors","chapter":"5 Vector operations","heading":"5.1 Loading vectors","text":"Load vector shapefile EU countries:vector contains polygons 27 countries European Union (EU).\nAdditionally, attribute table attached , providing information country name, ISO3 code, etc.\ncan see full list attributes using names(eu):","code":"\neu <- vect(\"data/EU/EU.shp\")\neu##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 27, 12  (geometries, attributes)\n##  extent      : -10.38743, 34.39352, 34.57181, 70.0864  (xmin, xmax, ymin, ymax)\n##  source      : EU.shp\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326) \n##  names       : CNTR_ID       CNTR_NAME NAME_ENGL NAME_FREN ISO3_CODE\n##  type        :   <chr>           <chr>     <chr>     <chr>     <chr>\n##  values      :      AT      Österreich   Austria  Autriche       AUT\n##                     BE Belgien-Belgiq~   Belgium  Belgique       BEL\n##                     BG        България  Bulgaria  Bulgarie       BGR\n##          SVRG_UN     CAPT EU_STAT EFTA_STAT CC_STAT  NAME_GERM   FID\n##            <chr>    <chr>   <chr>     <chr>   <chr>      <chr> <chr>\n##  UN Member State   Vienna       T         F       F Österreich    AT\n##  UN Member State Brussels       T         F       F    Belgien    BE\n##  UN Member State    Sofia       T         F       F  Bulgarien    BG\nnames(eu)##  [1] \"CNTR_ID\"   \"CNTR_NAME\" \"NAME_ENGL\" \"NAME_FREN\" \"ISO3_CODE\" \"SVRG_UN\"  \n##  [7] \"CAPT\"      \"EU_STAT\"   \"EFTA_STAT\" \"CC_STAT\"   \"NAME_GERM\" \"FID\""},{"path":"vector-operations.html","id":"plotting-vectors","chapter":"5 Vector operations","heading":"5.2 Plotting vectors","text":"Let’s put map:familiar maps, may recognize longitude-latitude projection: axes represent arc-degrees.\nsure, check CRS vector:expected, longlat CRS.\nargument proj = TRUE specifies want PROJ-string output.\nreadable standard output terra:cases, instance calculating areas polygons, longlat CRS recommended.","code":"\nplot(eu, col = \"dodgerblue\")\nnorth() #show the North\nsbar(1e3, type = \"bar\", divs = 4, below = \"kilometers\", xy = c(-10, 60)) #show a scale bar\ncrs(eu, proj = TRUE)## [1] \"+proj=longlat +datum=WGS84 +no_defs\"\ncrs(eu, proj = FALSE)## [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\""},{"path":"vector-operations.html","id":"area-extent","chapter":"5 Vector operations","heading":"5.3 Area extent","text":"terra, function expanse() calculate areas.\nread documentation, also specified longlat CRS accurate calculate areas.\nLet’s calcualte area country add attribute table vector:can now make map polygons filled colors representing county area:","code":"\nA <- expanse(eu, unit = \"km\")\neu$area <- A\neu[, c(\"CNTR_NAME\", \"area\")]##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 27, 2  (geometries, attributes)\n##  extent      : -10.38743, 34.39352, 34.57181, 70.0864  (xmin, xmax, ymin, ymax)\n##  source      : EU.shp\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326) \n##  names       :               CNTR_NAME      area\n##  type        :                   <chr>     <num>\n##  values      :              Österreich 8.386e+04\n##                Belgien-Belgique-België  3.07e+04\n##                               България 1.111e+05\n# a gradient palette with number of colors = countries\npal <- colorRampPalette(c(\"grey80\", \"tomato3\", \"tomato\"))(nrow(eu))\npal <- rev(pal[order(eu$area)]) #arrange colors\nplot(eu, col = pal) #adding a legend to vector maps is not easy and will leave it for another chapter.\nnorth()\nsbar(1e3, type = \"bar\", divs = 4, below = \"kilometers\", xy = c(-10, 60)) "},{"path":"vector-operations.html","id":"buffers-and-neighbours-of-a-polygon","chapter":"5 Vector operations","heading":"5.4 Buffers and neighbours of a polygon","text":"shapefile good shapefile, meaning people created took care boundaries countries overlap.\nIndeed, reason tension countries.\nHowever, can still trick way obtain neighbors countries.\nImagine enlarge countries, .e. expand borders small amount, let’s say 1km.\nopearation called buffering:done one country , overlap adjacent neighbors (non-adjacent ones closer 1km).\ncan use together terra::intersect() get neighbors:warning thrown telling use countries neighbors:islands (Cyprus, Ireland, Malta), correct.Importantly, terra special function get adjanceny polygons, called (surprisingly) adjacent().\nfunciton normally use; approach used teaching purposes.\nHowever, note , case, two approach give results:reason identical country close 1km less another also adjacent neighbor.","code":"\nb <- buffer(eu, 1e5) #100km for visualizing it\nplot(eu, col = \"dodgerblue\")\nlines(b)\nneigh_name <- as.list(rep(NA, nrow(eu)))\nneigh_area <- as.list(rep(NA, nrow(eu)))\nnames(neigh_name) <- eu$CNTR_NAME\nnames(neigh_area) <- eu$CNTR_NAME\n\n# iterate over countries\nfor (i in seq_len(nrow(eu))) {\n  b <- buffer(eu[i], 1e3)\n  ans <- intersect(eu[-i], b)\n  neigh_name[[i]] <- ans$CNTR_NAME\n  neigh_area[[i]] <- ans$area\n}## Warning: [intersect] no intersection\n\n## Warning: [intersect] no intersection\n\n## Warning: [intersect] no intersection\nnames(neigh_name)[sapply(neigh_name, length) == 0]## [1] \"Κύπρος-Kıbrıs\" \"Ireland-Éire\"  \"Malta-Malta\"\nadj <- adjacent(eu)\nneigh_name_correct <- as.list(rep(NA, nrow(eu)))\nnames(neigh_name_correct) <- eu$CNTR_NAME\nfor (i in seq_along(neigh_name_correct)) {\n  neigh_name_correct[[i]] <- eu$CNTR_NAME[adj[adj[, 1] == i, 2]]\n}\n\ncompare <- data.frame(\n  buffering = unlist(neigh_name),\n  correct = unlist(neigh_name_correct)\n)\nany(compare[, 1] != compare[, 2])## [1] FALSE\nhead(compare)##                   buffering         correct\n## Österreich1 Česká Republika Česká Republika\n## Österreich2     Deutschland     Deutschland\n## Österreich3    Magyarország    Magyarország\n## Österreich4          Italia          Italia\n## Österreich5       Slovinsko       Slovinsko\n## Österreich6       Slovensko       Slovensko"},{"path":"mapping.html","id":"mapping","chapter":"6 Mapping","heading":"6 Mapping","text":"One common goal GIS produce map phenomenon process.example, use data Italian National Insitute Statistics (ISTAT):Administrative division shapefile (https://www.istat.//archivio/222527).GDP regions, second administrative division State.data/ISTAT/ folder, respective subdirectories.Load vector shapefile EU countries:","code":"\nlibrary(terra)\n\n# shapefile of regions\nregs <- vect(\"data/ISTAT/Limiti01012024_g/Reg01012024_g/Reg01012024_g_WGS84.shp\")\n\n# shapefile of cities\ncities <- vect(\"data/ISTAT/Limiti01012024_g/Com01012024_g/Com01012024_g_WGS84.shp\")\n\n# noise pollution\nnoise <- read.csv(\"data/ISTAT/city-acoustic-noise.csv\")\nnoise <- noise[noise$TIME_PERIOD == 2012, ] #only 2012\nnoise <- noise[noise$TIME_PERIOD != \"IT\", ] #only city level\nnoise <- noise[noise$TYPE_OF_MONITORING == 1, ] #sensor type\nnoise <- noise[!is.na(noise$OBS_VALUE), ] #remove empty\nnoise <- noise[noise$DATA_TYPE == \"MON_LIM\", ] #monthly limit\n\n# not all cities studies: remove not studied\nstudied <- intersect(cities$PRO_COM_T, noise$REF_AREA)\ncities <- cities[cities$PRO_COM_T %in% studied]\nnoise <- noise[noise$REF_AREA %in% studied, ]\n\n# add attribute\ncities$noise <- noise$OBS_VALUE[sapply(noise$REF_AREA, \\(x) which(cities$PRO_COM_T == x))]\ncities <- cities[order(cities$noise)]\ncities <- cities[cities$noise > 0] #suspect data\n\n# map -----------\nnoise_vals <- unique(cities$noise)\ncolors <- colorRampPalette(c(\"green3\", \"tomato\"))(length(noise_vals))\npal <- c()\nfor ( x in noise_vals ) {\n  pal <- c(pal, rep(colors[which(x == noise_vals)], sum(cities$noise == x)))\n}\n\n#plot(regs)\n#plot(cities, col = as.numeric(cities$noise), add = TRUE)\n\n# regional statistics ----------\nregs$noise <- NA\nregs$noise_cv <- NA\nfor ( i in seq_along(regs) ) {\n  within <- relate(cities, regs[i], \"within\")\n  ids <- which(within, arr.ind = TRUE)[, \"row\"]\n  regs$noise[ids] <- mean(cities$noise[ids])\n  regs$noise_cv[ids] <-  sd(cities$noise[ids]) / mean(cities$noise[ids])\n}\nregs$noise <- as.numeric(regs$noise)\nregs$noise_cv <- as.numeric(regs$noise_cv)\n\nlayout(matrix(c(2, 3, 1, 1), byrow = TRUE, ncol = 2))\npar(mar = c(4, 4, 2, 2))\nscatter.smooth(\n  regs$noise, regs$noise_cv,\n  pch = 20, cex = 2, frame = FALSE,\n  xlab = \"Noise\",\n  ylab = \"Variability (CV)\"\n)\nplot(\n  regs,\n  \"noise\",\n  col = colorRampPalette(c(\"green2\", \"tomato\"))(20),\n  type = \"continuous\",\n  axes = FALSE,\n  main = \"Noise pollution\"\n)\nplot(\n  regs,\n  \"noise_cv\",\n  col = colorRampPalette(c(\"grey90\", \"dodgerblue2\"))(20),\n  type = \"continuous\",\n  axes = FALSE,\n  main = \"Variability (CV)\"\n)"}]
