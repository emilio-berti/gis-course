[{"path":"index.html","id":"preface","chapter":"Preface","heading":"Preface","text":"started learning GIS 2017 PhD.\nprogramming know, learnt making many mistakes.\nstill make mistakes, means still learning.\naim book guide started learning GIS saved mistakes.\nbook intended newcomers GIS; experienced users definitely look search somewhere else (likely stackoverflow.com).book divided three main parts:\n1. General introduction GIS.\n2. Fundamentals GIS analysis.\n3. GIS analysis Google Earth Engine.","code":""},{"path":"index.html","id":"software-requirements","chapter":"Preface","heading":"Software requirements","text":"first part book, introduce basic concepts GIS using R Python.\n, use terra package R shapely module Python.second part, cover fundamentals GIS analysis.\nexplain theory behind complement examples actual analyses, introducing common workflows R Python.\nuse R package terra Python moduels shapely, geopandas, fiona, plotly.third part, focus Google Earth Engine explain move heavy GIS analyses cloud.\nrequire basic understanding JavaScript Python object-oriented programming, well interface GEE using gee Python module.\npart may seem redunant first (move computation Google servers?), , analyses expand scale need access several databases, GEE shines great trade-complexity effectiveness.install packages modules used book, can use conda environment management system.\nenvironment file https://github.com/emilio-berti/gis-course/blob/master/conda/gis-course.yml.","code":"conda env create --file=gis-course.yml"},{"path":"a-history-of-gis.html","id":"a-history-of-gis","chapter":"A history of GIS","heading":"A history of GIS","text":"GIS started …","code":""},{"path":"projections.html","id":"projections","chapter":"1 Projections","heading":"1 Projections","text":"map projection 2D representation Earth surface.\nseveral type projections, approximating Earth surface different ways.\nImportantly, spatial data must associated coordinate reference system (CRS), defines 2D map Earth surface related.\nGIS courses, CRS usually briefly discussed talked .\nHowever, CRS quite complicated topic one can introduce many errors analysis:\nchoose wrong CRS, calculations can extremely biased.give brief introduction CRS two reasons:complex topic going details takes long time.Honestly, still figuring obscure details CRS want say incorrect things.","code":""},{"path":"projections.html","id":"projections-vs-geographic-crs","chapter":"1 Projections","heading":"1.1 Projections vs Geographic CRS","text":"geographic CRS one locations points described longitude latitude, .e. angle Prime meridian (almost mythological creature) location angle Equator location, respectively.\nused geographic CRS WGS84 (EPSG:4326).projected CRS system represent 3D Earth surface plane.\nRepresenting 3D object 2D plane accurately possible.\nTherefore, projectons always distort property Earth surface, particular, least one : distance, angular conformity, area.\nProjections can grouped types, depending property Earth surface distort:Conformal projections: correctly represent angles points , thus, shapes. E.g., ESRI:54004 (Mercator).Equidistant: correctly represent distances. E.g., ESRI:54002.Equal-area: corretly represent areas. E.g. ESRI:54034.ESRI stands Environmental Systems Research Institute, Inc., company developed ArcGIS created code standard projections.\ncommonly used standard maintained European Petroleum Survey Group (EPSG).\ninstance, World Mercator (conformal) also EPSG:3395.common projected CRS Universal Transverse Mercator projection (conformal), e.g. EPSG:32632.\ntalk later chapter.\ncan find overview ESRI EPSG projections https://spatialreference.org/.\nWikipedia also nice list property projection: https://en.wikipedia.org/wiki/List_of_map_projections","code":""},{"path":"shapefiles.html","id":"shapefiles","chapter":"2 Shapefiles","heading":"2 Shapefiles","text":"Shapefiles contain geospatial vector data, also called geometries.\nshapefile extension .shp usually accompanied files.\nCommon supplementary files :.shx = index geometries data model..dbf = attributes geometries table format..prj = WKT representation coordinate reference system.core concept shapefiles geographic features stored using three fundamental geometry types:Points, defined coordinates \\((x, y)\\).Lines, defined two points line interpolating .Polygons, defiend several lines.three fundamental types can also “stacked”, e.g. one spatial feature can represented multiple points, lines, polygons.\ncase, talk multipoints, multilines, multipolygons.\ndifference multilines polygons polygon inscribe area space, creates “inside” area “outside” one, multilines .","code":""},{"path":"shapefiles.html","id":"geometries-in-r","chapter":"2 Shapefiles","heading":"2.1 Geometries in R","text":"Let’s see exampled R using package terra.\nRemember load package already: library(terra).\nterra, hustle came older GIS software removed, geometries can simply created using vect() function.creates first geometry, point origin.\nmeaningful, however, must assign coordinate reference system geometry.\ncan done initialization .terra USE FUNDAMENTAL TYPE?Geometries can converted types casting.\nterra, , made extremely easy.\nLet’s create points.cast lines using .lines().may want cast polygons, notice however lines inscribe area space, .e. “closed”.Trying cast lines polygons, return empty geometry.cast lines polygons, two points must identical.want cast points polygons, considered best practice first cast lines cast polygons (just ).\nTrying cast points polygons directly can introduce errors, works .","code":"\nxy <- matrix(c(0, 0), ncol = 2)\npoi <- vect(xy)\ngeomtype(poi)## [1] \"points\"\npoi <- vect(xy, crs = \"EPSG:4326\")\npoi##  class       : SpatVector \n##  geometry    : points \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 0, 0, 0, 0  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)\nxy <- matrix(seq_len(10), ncol = 2)\npois <- vect(xy, crs = \"EPSG:4326\")\ngeomtype(pois)## [1] \"points\"\nls <- as.lines(pois)\ngeomtype(ls)## [1] \"lines\"\nplot(ls)\npoints(pois, cex = 2)\npol = as.polygons(ls)\ngeomtype(pol)## [1] \"none\"\nxy <- matrix(seq_len(10), ncol = 2)\nxy <- rbind(xy, cbind(5, 6)) #add bottom-right point\nxy <- rbind(xy, xy[1, ]) #add again first point\npois <- vect(xy, crs = \"EPSG:4326\")\nls <- as.lines(pois)\npol <- as.polygons(ls)\npol##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 1, 5, 6, 10  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)"},{"path":"rasters.html","id":"rasters","chapter":"3 Rasters","heading":"3 Rasters","text":"rasters fundamentally 2D matrices matadata, useful understand matrix jumping straight topic.\n2D matrix \\(\\) mathematical object can represented grid.\nelements \\(a_{ij}\\) matrix \\(\\) called entries.\nsubscript \\(a_{ij}\\) indicate row column coordinates entries.\nexample, \\(a_{1,1}\\) element first row first column, \\(a_{3,4}\\) element third row fourth column.","code":""},{"path":"rasters.html","id":"matrices-in-r","chapter":"3 Rasters","heading":"3.1 Matrices in R","text":"R provides native support matrices.\nfact, R designed work matrices, statistical models (R’s courtyard) can represented matrices.creating matrix, two import things often neglected.\nFirst, specifying byrow = TRUE, make sure values contained vals inserted matrix row-wise: \\(a_{12}\\) second value vals.\nargument can omitted inserting elements column-wise preferred; case, \\(a_{12}\\) fourth element vals.\nfind bit confusing, tend prefer byrow = TRUE work accordingly.\nwant recommend choice, keep mind byrow argument matrix looks weird.\nSecond, least one ncol nrow specified, matrix one column (column vectors).\nspecify one two, R infer dimension.\ncan specify invite clarity, whenever possible.","code":"\nvals <- seq_len(9)\nA <- matrix(vals, byrow = TRUE, nrow = 3, ncol = 3)"},{"path":"rasters.html","id":"rasters-1","chapter":"3 Rasters","heading":"3.2 Rasters","text":"raster basically 2D matrix associated metadata.\nimportant metadata define:spatial extent.spatial resolution.coordinate reference system, crs.raster without three metadata , cases, useless.","code":""},{"path":"rasters.html","id":"rasters-in-r","chapter":"3 Rasters","heading":"3.3 Rasters in R","text":"R, terra provides need work rasters.\ncreate raster, can use rast() function.\ncan use input matrix.dataframe.rast() also used read rasters files.write rasters files, writeRaster() function used.overwrite datatype arguments optional, strongly recommend always include .\noverwrite = TRUE simply make sure , raster already exists disk, overwritten; terra, defaults, throw error file exists overwrite = FALSE, safer, tends annoying long run.\ndatatype specifies numeric type matrix elements.\nAvailable types signed _u_nsigned _int_egers _fl_oa_t_ing point numbers.\nalso specify number bytes use entry.\nAvailable dataype choices :INT1U, unsigned integer 1 byte: \\(\\[0, 2^8]\\).INT2U, unsigned integer 2 bytes: \\(\\[0, 2^{16}]\\).INT2S, signed integer 2 bytes: \\(\\[-2^8 + 1, 2^8]\\).INT4U, unsigned integer 4 bytes: \\(\\[0, 2^{32}]\\).INT4S, signed integer 4 bytes: \\(\\[-2^{16} + 1, 2^{16}]\\).FLT4S, signed floating point (real) number 4 bytes: \\(\\[1.2 \\cdot 10^{-38}, 3.4 \\cdot 10^{38}]\\)FLT8S, signed floating point (real) number 8 bytes: \\(\\[2.3 \\cdot 10^{-308}, 1.7 \\cdot 10^{308}]\\)can actually store numbers also outside range numeric types, come cost precision, try avoid going outside ranges.\nmean always save files FLT8S, require disk space slow writing/reading operations.\nexample, want store elevation global scale precision one meter, INT2U optimal choice, smallest type can store information.","code":"\nr <- rast(A, crs = \"EPSG:4326\")\nr## class       : SpatRaster \n## dimensions  : 3, 3, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0, 3, 0, 3  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        : lyr.1 \n## min value   :     1 \n## max value   :     9\nd <- data.frame(\n  x = rep(seq_len(10), 10), #x coord\n  y = rep(seq_len(10), each = 10), #y coord\n  z = seq_len(100) #values\n)\nr <- rast(d, crs = \"EPSG:4326\")\nr <- rast(\"some-file.tif\")\nwriteRaster(r, \"some-file.tif\", overwrite = TRUE, datatype = \"INT4U\")"},{"path":"basic-operations.html","id":"basic-operations","chapter":"4 Basic Operations","heading":"4 Basic Operations","text":"operations staple GIS.\nexample: distance two features? area polygon? value raster specific locations?GitHub repository, put data folder contains data can use.","code":""},{"path":"vector-operations.html","id":"vector-operations","chapter":"5 Vector operations","heading":"5 Vector operations","text":"","code":""},{"path":"vector-operations.html","id":"loading-vectors","chapter":"5 Vector operations","heading":"5.1 Loading vectors","text":"Load vector shapefile EU countries:vector contains polygons 27 countries European Union (EU).\nAdditionally, attribute table attached , providing information country name, ISO3 code, etc.\ncan see full list attributes using names(eu):","code":"\neu <- vect(\"data/EU/EU.shp\")\neu##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 27, 12  (geometries, attributes)\n##  extent      : -10.38743, 34.39352, 34.57181, 70.0864  (xmin, xmax, ymin, ymax)\n##  source      : EU.shp\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326) \n##  names       : CNTR_ID       CNTR_NAME NAME_ENGL NAME_FREN ISO3_CODE\n##  type        :   <chr>           <chr>     <chr>     <chr>     <chr>\n##  values      :      AT      Österreich   Austria  Autriche       AUT\n##                     BE Belgien-Belgiq~   Belgium  Belgique       BEL\n##                     BG        България  Bulgaria  Bulgarie       BGR\n##          SVRG_UN     CAPT EU_STAT EFTA_STAT CC_STAT  NAME_GERM   FID\n##            <chr>    <chr>   <chr>     <chr>   <chr>      <chr> <chr>\n##  UN Member State   Vienna       T         F       F Österreich    AT\n##  UN Member State Brussels       T         F       F    Belgien    BE\n##  UN Member State    Sofia       T         F       F  Bulgarien    BG\nnames(eu)##  [1] \"CNTR_ID\"   \"CNTR_NAME\" \"NAME_ENGL\" \"NAME_FREN\" \"ISO3_CODE\" \"SVRG_UN\"  \n##  [7] \"CAPT\"      \"EU_STAT\"   \"EFTA_STAT\" \"CC_STAT\"   \"NAME_GERM\" \"FID\""},{"path":"vector-operations.html","id":"plotting-vectors","chapter":"5 Vector operations","heading":"5.2 Plotting vectors","text":"Let’s put map:familiar maps, may recognize longitude-latitude projection: axes represent arc-degrees.\nsure, check CRS vector:expected, longlat CRS.\nargument proj = TRUE specifies want PROJ-string output.\nreadable standard output terra:cases, instance calculating areas polygons, longlat CRS recommended.","code":"\nplot(eu, col = \"dodgerblue\")\nnorth() #show the North\nsbar(1e3, type = \"bar\", divs = 4, below = \"kilometers\", xy = c(-10, 60)) #show a scale bar\ncrs(eu, proj = TRUE)## [1] \"+proj=longlat +datum=WGS84 +no_defs\"\ncrs(eu, proj = FALSE)## [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\""},{"path":"vector-operations.html","id":"area-extent","chapter":"5 Vector operations","heading":"5.3 Area extent","text":"terra, function expanse() calculate areas.\nread documentation, also specified longlat CRS accurate calculate areas.\nLet’s calcualte area country add attribute table vector:can now make map polygons filled colors representing county area:","code":"\nA <- expanse(eu, unit = \"km\")\neu$area <- A\neu[, c(\"CNTR_NAME\", \"area\")]##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 27, 2  (geometries, attributes)\n##  extent      : -10.38743, 34.39352, 34.57181, 70.0864  (xmin, xmax, ymin, ymax)\n##  source      : EU.shp\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326) \n##  names       :               CNTR_NAME      area\n##  type        :                   <chr>     <num>\n##  values      :              Österreich 8.386e+04\n##                Belgien-Belgique-België  3.07e+04\n##                               България 1.111e+05\n# a gradient palette with number of colors = countries\npal <- colorRampPalette(c(\"grey80\", \"tomato3\", \"tomato\"))(nrow(eu))\npal <- rev(pal[order(eu$area)]) #arrange colors\nplot(eu, col = pal) #adding a legend to vector maps is not easy and will leave it for another chapter.\nnorth()\nsbar(1e3, type = \"bar\", divs = 4, below = \"kilometers\", xy = c(-10, 60)) "},{"path":"vector-operations.html","id":"buffers-and-neighbours-of-a-polygon","chapter":"5 Vector operations","heading":"5.4 Buffers and neighbours of a polygon","text":"shapefile good shapefile, meaning people created took care boundaries countries overlap.\nIndeed, reason tension countries.\nHowever, can still trick way obtain neighbors countries.\nImagine enlarge countries, .e. expand borders small amount, let’s say 1km.\nopearation called buffering:done one country , overlap adjacent neighbors (non-adjacent ones closer 1km).\ncan use together terra::intersect() get neighbors:warning thrown telling use countries neighbors:islands (Cyprus, Ireland, Malta), correct.Importantly, terra special function get adjanceny polygons, called (surprisingly) adjacent().\nfunciton normally use; approach used teaching purposes.\nHowever, note , case, two approach give results:reason identical country close 1km less another also adjacent neighbor.","code":"\nb <- buffer(eu, 1e5) #100km for visualizing it\nplot(eu, col = \"dodgerblue\")\nlines(b)\nneigh_name <- as.list(rep(NA, nrow(eu)))\nneigh_area <- as.list(rep(NA, nrow(eu)))\nnames(neigh_name) <- eu$CNTR_NAME\nnames(neigh_area) <- eu$CNTR_NAME\n\n# iterate over countries\nfor (i in seq_len(nrow(eu))) {\n  b <- buffer(eu[i], 1e3)\n  ans <- intersect(eu[-i], b)\n  neigh_name[[i]] <- ans$CNTR_NAME\n  neigh_area[[i]] <- ans$area\n}## Warning: [intersect] no intersection\n\n## Warning: [intersect] no intersection\n\n## Warning: [intersect] no intersection\nnames(neigh_name)[sapply(neigh_name, length) == 0]## [1] \"Κύπρος-Kıbrıs\" \"Ireland-Éire\"  \"Malta-Malta\"\nadj <- adjacent(eu)\nneigh_name_correct <- as.list(rep(NA, nrow(eu)))\nnames(neigh_name_correct) <- eu$CNTR_NAME\nfor (i in seq_along(neigh_name_correct)) {\n  neigh_name_correct[[i]] <- eu$CNTR_NAME[adj[adj[, 1] == i, 2]]\n}\n\ncompare <- data.frame(\n  buffering = unlist(neigh_name),\n  correct = unlist(neigh_name_correct)\n)\nany(compare[, 1] != compare[, 2])## [1] FALSE\nhead(compare)##                   buffering         correct\n## Österreich1 Česká Republika Česká Republika\n## Österreich2     Deutschland     Deutschland\n## Österreich3    Magyarország    Magyarország\n## Österreich4          Italia          Italia\n## Österreich5       Slovinsko       Slovinsko\n## Österreich6       Slovensko       Slovensko"}]
