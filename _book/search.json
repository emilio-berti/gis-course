[{"path":"index.html","id":"preface","chapter":"Preface","heading":"Preface","text":"started learning GIS 2017 PhD.\nprogramming know, learnt making many mistakes.\nstill make mistakes, means still learning.\naim book guide started learning GIS saved mistakes.\nbook intended newcomers GIS; experienced users definitely look search somewhere else (likely stackoverflow.com).book divided three main parts:\n1. General introduction GIS.\n2. Fundamentals GIS analysis.\n3. GIS analysis Google Earth Engine.","code":""},{"path":"index.html","id":"software-requirements","chapter":"Preface","heading":"Software requirements","text":"first part book, introduce basic concepts GIS using R Python.\n, use terra package R shapely module Python.second part, cover fundamentals GIS analysis.\nexplain theory behind complement examples actual analyses, introducing common workflows R Python.\nuse R package terra Python moduels shapely, geopandas, fiona, plotly.third part, focus Google Earth Engine explain move heavy GIS analyses cloud.\nrequire basic understanding JavaScript Python object-oriented programming, well interface GEE using gee Python module.\npart may seem redunant first (move computation Google servers?), , analyses expand scale need access several databases, GEE shines great trade-complexity effectiveness.install packages modules used book, can use conda environment management system.\nenvironment file https://github.com/emilio-berti/gis-course/blob/master/conda/gis-course.yml.","code":"conda env create --file=gis-course.yml"},{"path":"a-history-of-gis.html","id":"a-history-of-gis","chapter":"A history of GIS","heading":"A history of GIS","text":"GIS started …","code":""},{"path":"projections.html","id":"projections","chapter":"Projections","heading":"Projections","text":"used","code":""},{"path":"shapefiles.html","id":"shapefiles","chapter":"Shapefiles","heading":"Shapefiles","text":"Shapefiles contain geospatial vector data, also called geometries.\nshapefile extension .shp usually accompanied files.\nCommon supplementary files :.shx, contains index geometries data model..dbf, contains attributes geometries table format..prj, contains WKT representation coordinate reference system.core concept shapefiles geographic features stored using three fundamental geometry types:Points, defined coordinates \\((x, y)\\).Lines, defined two points line interpolating .Polygons, defiend several lines.three fundamental types can also “stacked”, e.g. one spatial feature can represented multiple points, lines, polygons.\ncase, talk multipoints, multilines, multipolygons.\ndifference multilines polygons polygon inscribe area space, creates “inside” area “outside” one, multilines .","code":""},{"path":"shapefiles.html","id":"geometries-in-r","chapter":"Shapefiles","heading":"Geometries in R","text":"Let’s see exampled R using package terra.\nRemember load package already: library(terra).\nterra, hustle came older GIS software removed, geometries can simply created using vect() function.creates first geometry, point origin.\nmeaningful, however, must assign coordinate reference system geometry.\ncan done initialization .terra USE FUNDAMENTAL TYPE?Geometries can converted types casting.\nterra, , made extremely easy.\nLet’s create points.cast lines using .lines().may want cast polygons, notice however lines inscribe area space, .e. “closed”.Trying cast lines polygons, return empty geometry.cast lines polygons, two points must identical.want cast points polygons, considered best practice first cast lines cast polygons (just ).\nTrying cast points polygons directly can introduce errors, works .","code":"\nxy <- matrix(c(0, 0), ncol = 2)\npoi <- vect(xy)\ngeomtype(poi)## [1] \"points\"\npoi <- vect(xy, crs = \"EPSG:4326\")\npoi##  class       : SpatVector \n##  geometry    : points \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 0, 0, 0, 0  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)\nxy <- matrix(seq_len(10), ncol = 2)\npois <- vect(xy, crs = \"EPSG:4326\")\ngeomtype(pois)## [1] \"points\"\nls <- as.lines(pois)\ngeomtype(ls)## [1] \"lines\"\nplot(ls)\npoints(pois, cex = 2)\npol = as.polygons(ls)\ngeomtype(pol)## [1] \"none\"\nxy <- matrix(seq_len(10), ncol = 2)\nxy <- rbind(xy, cbind(5, 6)) #add bottom-right point\nxy <- rbind(xy, xy[1, ]) #add again first point\npois <- vect(xy, crs = \"EPSG:4326\")\nls <- as.lines(pois)\npol <- as.polygons(ls)\npol##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 1, 5, 6, 10  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)"},{"path":"shapefiles.html","id":"geometries-in-python","chapter":"Shapefiles","heading":"Geometries in Python","text":"Finally, shapely GeometryCollection type store geometries one type.","code":"from shapely.geometry import Point, MultiPoint\n\npoi = Point(0, 0)\npoi.wkt## 'POINT (0 0)'pois = MultiPoint([[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]])\npois.wkt## 'MULTIPOINT (0 0, 0 1, 1 1, 1 0, 0 0)'from shapely.geometry import LineString, LinearRing\n\nls = LineString([[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]])\nlr = LinearRing([[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]])\nls.wkt## 'LINESTRING (0 0, 0 1, 1 1, 1 0, 0 0)'from shapely.geometry import Polygon, MultiPolygon\n\npol = Polygon([[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]])\npols = MultiPolygon([pol for i in range(3)])\npols.wkt## 'MULTIPOLYGON (((0 0, 0 1, 1 1, 1 0, 0 0)), ((0 0, 0 1, 1 1, 1 0, 0 0)), ((0 0, 0 1, 1 1, 1 0, 0 0)))'from shapely.geometry import GeometryCollection\n\ncoll = GeometryCollection([pois, ls, pol])\ncoll.wkt## 'GEOMETRYCOLLECTION (MULTIPOINT (0 0, 0 1, 1 1, 1 0, 0 0), LINESTRING (0 0, 0 1, 1 1, 1 0, 0 0), POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0)))'"},{"path":"rasters.html","id":"rasters","chapter":"Rasters","heading":"Rasters","text":"rasters fundamentally 2D matrices matadata, useful understand matrix jumping straight topic.\n2D matrix \\(\\) mathematical object can represented grid.\nelements \\(a_{ij}\\) matrix \\(\\) called entries.\nsubscript \\(a_{ij}\\) indicate row column coordinates entries.\nexample, \\(a_{1,1}\\) element first row first column, \\(a_{3,4}\\) element third row fourth column.","code":""},{"path":"rasters.html","id":"matrices-in-r","chapter":"Rasters","heading":"Matrices in R","text":"R provides native support matrices.\nfact, R designed work matrices, statistical models (R’s courtyard) can represented matrices.creating matrix, two import things often neglected.\nFirst, specifying byrow = TRUE, make sure values contained vals inserted matrix row-wise: \\(a_{12}\\) second value vals.\nargument can omitted inserting elements column-wise preferred; case, \\(a_{12}\\) fourth element vals.\nfind bit confusing, tend prefer byrow = TRUE work accordingly.\nwant recommend choice, keep mind byrow argument matrix looks weird.\nSecond, least one ncol nrow specified, matrix one column (column vectors).\nspecify one two, R infer dimension.\ncan specify invite clarity, whenever possible.","code":"\nvals <- seq_len(9)\nA <- matrix(vals, byrow = TRUE, nrow = 3, ncol = 3)"},{"path":"rasters.html","id":"rasters-1","chapter":"Rasters","heading":"Rasters","text":"raster basically 2D matrix associated metadata.\nimportant metadata define:spatial extent.spatial resolution.coordinate reference system, crs.raster without three metadata , cases, useless.","code":""},{"path":"rasters.html","id":"rasters-in-r","chapter":"Rasters","heading":"Rasters in R","text":"R, terra provides need work rasters.\ncreate raster, can use rast() function.\ncan use input matrix.dataframe.rast() also used read rasters files.write rasters files, writeRaster() function used.overwrite datatype arguments optional, strongly recommend always include .\noverwrite = TRUE simply make sure , raster already exists disk, overwritten; terra, defaults, throw error file exists overwrite = FALSE, safer, tends annoying long run.\ndatatype specifies numeric type matrix elements.\nAvailable types signed _u_nsigned _int_egers _fl_oa_t_ing point numbers.\nalso specify number bytes use entry.\nAvailable dataype choices :INT1U, unsigned integer 1 byte: \\(\\[0, 2^8]\\).INT2U, unsigned integer 2 bytes: \\(\\[0, 2^{16}]\\).INT2S, signed integer 2 bytes: \\(\\[-2^8 + 1, 2^8]\\).INT4U, unsigned integer 4 bytes: \\(\\[0, 2^{32}]\\).INT4S, signed integer 4 bytes: \\(\\[-2^{16} + 1, 2^{16}]\\).FLT4S, signed floating point (real) number 4 bytes: \\(\\[1.2 \\cdot 10^{-38}, 3.4 \\cdot 10^{38}]\\)FLT8S, signed floating point (real) number 8 bytes: \\(\\[2.3 \\cdot 10^{-308}, 1.7 \\cdot 10^{308}]\\)can actually store numbers also outside range numeric types, come cost precision, try avoid going outside ranges.\nmean always save files FLT8S, require disk space slow writing/reading operations.\nexample, want store elevation global scale precision one meter, INT2U optimal choice, smallest type can store information.","code":"\nr <- rast(A, crs = \"EPSG:4326\")\nr## class       : SpatRaster \n## dimensions  : 3, 3, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0, 3, 0, 3  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source      : memory \n## name        : lyr.1 \n## min value   :     1 \n## max value   :     9\nd <- data.frame(\n  x = rep(seq_len(10), 10), #x coord\n  y = rep(seq_len(10), each = 10), #y coord\n  z = seq_len(100) #values\n)\nr <- rast(d, crs = \"EPSG:4326\")\nr <- rast(\"some-file.tif\")\nwriteRaster(r, \"some-file.tif\", overwrite = TRUE, datatype = \"INT4U\")"},{"path":"rasters.html","id":"rasters-in-python","chapter":"Rasters","heading":"Rasters in Python","text":"Python, reading plotting rasters easily achieved using rasterio matplotlib.raster operations , however, much convoluted equivalent R.\nintroductory course GIS, preferred omit raster manipulation Python sake mental health.\naddition, completely honest, don’t know much .\nalmost never use Python raster manipulation , , ’s last resort desperate cases.\nseveral reasons :terra R provides much friendly environment work rasters rasterio.QGIS Python modules work rasters much friendly can accessed easily (also source code) GUI.Almost raster manipulations perform larger projects, .e. scalability important R starts feel bit stiff, can performed Google servers quite easily.one big exception : Python API Google Earth Engine.\nsee …, Google provides API Python access remote-sensing products computing power.\nPython scalability comes handy, don’t fooled: Python API just way interface Google servers, operations actually performed Python using Python modules.","code":"import rasterio\nfrom matplotlib import pyplot as plt\n\nr = rasterio.open('raster-file.tif')\nplt.imshow(r.read(1))\nplt.show()"},{"path":"basic-operations.html","id":"basic-operations","chapter":"Basic Operations","heading":"Basic Operations","text":"operations staple GIS.\nexample: distance two features? area polygon? value raster specific locations?","code":""}]
