[{"path":"index.html","id":"preface","chapter":"Preface","heading":"Preface","text":"started learning GIS 2017 PhD.\nfirst approached GIS using ArcGIS, hated guts.\nprefer typing terminal rather clicking icons, quickly switched R.\nuse R package terra thorough course.\ncan replicate content course using python, leave another time.\ncourse intended newcomers GIS; experienced users definitely look somewhere else (likely stackoverflow.com).course divided three main parts:General introduction GIS.Fundamentals GIS analysis.GIS analysis Google Earth Engine.first part course, introduce basic concepts GIS using R.\nsecond part, cover fundamentals GIS analysis.\nexplain theory behind complement examples actual analyses, introducing common workflows R.\nthird part, focus Google Earth Engine explain move heavy GIS analyses cloud.\nrequire basic understanding JavaScript.\ngreat talk interface Google Earth Engine using python, topic probably advanced focus another course.","code":""},{"path":"index.html","id":"software-requirements","chapter":"Preface","heading":"Software requirements","text":"install packages modules used book, can use conda environment management system.\nenvironment file https://github.com/emilio-berti/gis-course/blob/master/conda/gis-course.yml.","code":"conda env create --file=gis-course.yml"},{"path":"the-why-of-gis.html","id":"the-why-of-gis","chapter":"The why of GIS","heading":"The why of GIS","text":"Humans always interested mapping Earth.\nAnaximander among first publish map known world 6th century BC.\nFigure 0.1: Reconstruction map known world Anaximander.\nMaps particularly realistic, people really use way now.\nLooking maps battles, examples, modern thing; ancient people simply .\n“Age Exploration”, accurate maps make difference riches starving sea, maps became realistic.\nFigure 0.2: portolan map Age Discovery.\nJump forward another 400 years many major technological advancements get Information Age, cartographic software started developed.\nGIS comprise hardware software collect, store, manage, analyze geographic data.\nToday, several GIS hardware software publicly accessible used many fields: urban planning, climate modeling, mining, warfare, etc.\nmay surprising ecologist, current GIS tools tightly linked mineral oil exploration, European Petroleum Survey Group (EPSG), warfare, GPS GLONASS.\nNevertheless, use GIS well-humanity stick biogeographic analyses.\nFigure 0.3: example map produced using QGIS, free GIS software.\n","code":""},{"path":"projections.html","id":"projections","chapter":"1 Projections","heading":"1 Projections","text":"map projection 2D representation Earth surface.\nTechincally, projection set transformations represent surface Earth plane.\nFigure 1.1: Earth sphere.\nseveral type projections, approximating Earth surface different ways.\nImportantly, spatial data must associated coordinate reference system (CRS), defines 2D map Earth surface related.\nGIS courses, CRS usually briefly discussed talked .\nHowever, CRS quite complicated topic one can introduce many errors analysis:\nchoose wrong CRS, calculations can extremely biased.give brief introduction CRS two reasons:complex topic going details takes long time.Honestly, still figuring obscure details CRS want say incorrect things.","code":""},{"path":"projections.html","id":"geographic-vs-projectes-crs","chapter":"1 Projections","heading":"1.1 Geographic vs Projectes CRS","text":"geographic CRS one locations points described longitude latitude, .e. angle Prime meridian (almost mythological creature) location angle Equator location, respectively.\nused geographic CRS WGS84 (EPSG:4326).projected CRS system represent 3D Earth surface plane.\nRepresenting 3D object 2D plane accurately possible.\nTherefore, projectons always distort property Earth surface, particular, least one : distance, angular conformity, area.\nProjections can grouped types, depending property Earth surface distort:Conformal projections: correctly represent angles points , thus, shapes. E.g., ESRI:54004 (Mercator).Equidistant: correctly represent distances. E.g., ESRI:54002.Equal-area: corretly represent areas. E.g. ESRI:54034.ESRI stands Environmental Systems Research Institute, Inc., company developed ArcGIS created code standard projections.\ncommonly used standard maintained European Petroleum Survey Group (EPSG).\ninstance, World Mercator (conformal) also EPSG:3395.common projected CRS Universal Transverse Mercator projection (conformal), e.g. EPSG:32632.\ntalk later chapter.\ncan find overview ESRI EPSG projections https://spatialreference.org/.\nWikipedia also nice list property projection: https://en.wikipedia.org/wiki/List_of_map_projections","code":""},{"path":"vectors.html","id":"vectors","chapter":"2 Vectors","heading":"2 Vectors","text":"Vectors (shapefiles) contain geospatial vector data, also called geometries.\nshapefile extension .shp usually accompanied files.\nCommon supplementary files :.shx = index geometries data model..dbf = attributes geometries table format..prj = WKT representation coordinate reference system.core concept shapefiles geographic features stored using three fundamental geometry types:Points, defined coordinates \\((x, y)\\).Lines, defined two points line interpolating .Polygons, defiend several lines.three fundamental types can also “stacked”, e.g. one spatial feature can represented multiple points, lines, polygons.\ncase, talk multipoints, multilines, multipolygons.\ndifference multilines polygons polygon inscribe area space, creates “inside” area “outside” one, multilines .","code":""},{"path":"vectors.html","id":"geometries-in-r","chapter":"2 Vectors","heading":"2.1 Geometries in R","text":"Let’s see exampled R using package terra.\nRemember load package already: library(terra).\nterra, hustle came older GIS software removed, geometries can simply created using vect() function.creates first geometry, point origin.\nmeaningful, however, must assign coordinate reference system geometry.\ncan done initialization .Geometries can converted types casting.\nterra made extremely easy.\nLet’s create points.cast lines using .lines().may want cast polygons, notice however lines inscribe area space, .e. “closed”.Trying cast lines polygons, return empty geometry.cast lines polygons, two points must identical.want cast points polygons, considered best practice first cast lines cast polygons (just ).\nTrying cast points polygons directly can introduce errors, works .geometry set properties.\nPoints coordinates:Lines length:polygons perimeter area:Note lines polygons also coordinates, breaking points straight lines, defined points:","code":"\nxy <- matrix(c(0, 0), ncol = 2)\npoi <- vect(xy)\ngeomtype(poi)## [1] \"points\"\npoi <- vect(xy, crs = \"EPSG:4326\")\npoi##  class       : SpatVector \n##  geometry    : points \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 0, 0, 0, 0  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)\nxy <- matrix(seq_len(10), ncol = 2)\npois <- vect(xy, crs = \"EPSG:4326\")\ngeomtype(pois)## [1] \"points\"\nls <- as.lines(pois)\ngeomtype(ls)## [1] \"lines\"\nplot(ls)\npoints(pois, cex = 2)\npol = as.polygons(ls)\ngeomtype(pol)## [1] \"none\"\nxy <- matrix(seq_len(10), ncol = 2)\nxy <- rbind(xy, cbind(5, 6)) #add bottom-right point\nxy <- rbind(xy, xy[1, ]) #add again first point\npois <- vect(xy, crs = \"EPSG:4326\")\nls <- as.lines(pois)\npol <- as.polygons(ls)\npol##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 1, 0  (geometries, attributes)\n##  extent      : 1, 5, 6, 10  (xmin, xmax, ymin, ymax)\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326)\n# show it\nplot(pol, col = \"dodgerblue\", alpha = .5)\nlines(ls, col = \"tomato\", lw = 3)\npoints(pois, cex = 3)\ngeom(pois)[, c(\"x\", \"y\")] #coordinates of points##      x  y\n## [1,] 1  6\n## [2,] 2  7\n## [3,] 3  8\n## [4,] 4  9\n## [5,] 5 10\n## [6,] 5  6\n## [7,] 1  6\nperim(ls) #length of line## [1] 1509805\nperim(pol) #perimeter of polygon## [1] 1509805\nexpanse(pol, unit = \"km\") #area of polygon## [1] 97586.03\ngeom(pol)##      geom part x  y hole\n## [1,]    1    1 1  6    0\n## [2,]    1    1 2  7    0\n## [3,]    1    1 3  8    0\n## [4,]    1    1 4  9    0\n## [5,]    1    1 5 10    0\n## [6,]    1    1 5  6    0\n## [7,]    1    1 1  6    0"},{"path":"vectors.html","id":"create-geometry-in-r-interactively","chapter":"2 Vectors","heading":"2.2 Create geometry in R interactively","text":"R terra nice feature allows draw plot save resulting geometry environment.\nachieved using function draw(), takes argument type geometry want draw (points, line, polygon, extent).just left-click map.\ndone, right click output saved variable drawing.useful want zoom region map draw coarse polygons don’t want open interactive GIS software, QGIS.","code":"\nplot(pol, col = \"dodgerblue3\", alpha = .5)\ndrawing = draw(\"lines\")"},{"path":"rasters.html","id":"rasters","chapter":"3 Rasters","heading":"3 Rasters","text":"rasters fundamentally 2D matrices matadata, useful understand matrix jumping straight topic.\n2D matrix \\(\\) mathematical object can represented grid.\nelements \\(A_{ij}\\) matrix \\(\\) called entries.\nsubscript \\(A_{ij}\\) indicate row column coordinates entries.\nexample, \\(A_{1,1}\\) element first row first column, \\(A_{3,4}\\) element third row fourth column.","code":""},{"path":"rasters.html","id":"matrices-in-r","chapter":"3 Rasters","heading":"3.1 Matrices in R","text":"R provides native support matrices.\nfact, R designed work matrices, statistical models can represented operation matrices.creating matrix, two import things often neglected.\nFirst, specifying byrow = TRUE, make sure values contained vals inserted matrix row-wise, .e. \\(A_{1,1}\\) = vals[1], \\(A_{1,2}\\) = vals[2], etc.\nargument can omitted inserting elements column-wise preferred; case, \\(A_{2,1}\\) = vals[2], etc..Second, least one ncol nrow specified, matrix one column (column vectors).\nspecify one two, R infer dimension.\ncan specify invite clarity, whenever possible.","code":"\nvals <- seq_len(9)\nA <- matrix(vals, byrow = TRUE, nrow = 3, ncol = 3)\nA##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9"},{"path":"rasters.html","id":"rasters-1","chapter":"3 Rasters","heading":"3.2 Rasters","text":"raster basically 2D matrix associated metadata.\nimportant metadata define:spatial extent.spatial resolution.coordinate reference system, crs.raster without three metadata , cases, useless.","code":""},{"path":"rasters.html","id":"rasters-in-r","chapter":"3 Rasters","heading":"3.3 Rasters in R","text":"R, terra provides need work rasters.\ncreate raster, can use rast() function.\ncan use input matrix.dataframe.rast() also used read rasters files.write rasters files, writeRaster() function used.overwrite datatype arguments optional, strongly recommend always include .\noverwrite = TRUE simply make sure , raster already exists disk, overwritten.\nterra, defaults, throw error file exists overwrite = FALSE, can annoying working servers.\ndatatype specifies numeric type matrix elements.\nAvailable types signed unsigned integer float.\nalso specify number bytes use entry.\nAvailable dataype choices :INT1U, unsigned integer 1 byte: \\(\\[0, 2^8]\\).INT2U, unsigned integer 2 bytes: \\(\\[0, 2^{16}]\\).INT2S, signed integer 2 bytes: \\(\\[-2^8 + 1, 2^8]\\).INT4U, unsigned integer 4 bytes: \\(\\[0, 2^{32}]\\).INT4S, signed integer 4 bytes: \\(\\[-2^{16} + 1, 2^{16}]\\).FLT4S, signed floating point (real) number 4 bytes: \\(\\[1.2 \\cdot 10^{-38}, 3.4 \\cdot 10^{38}]\\)FLT8S, signed floating point (real) number 8 bytes: \\(\\[2.3 \\cdot 10^{-308}, 1.7 \\cdot 10^{308}]\\)can actually store numbers also outside range numeric types, come cost precision, try avoid going outside ranges.\nmean always save files FLT8S, require disk space slow writing/reading operations.\nexample, want store elevation global scale precision one meter, INT2U optimal choice, smallest type can store information.","code":"\nr <- rast(A, crs = \"EPSG:4326\")\nr## class       : SpatRaster \n## dimensions  : 3, 3, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0, 3, 0, 3  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        : lyr.1 \n## min value   :     1 \n## max value   :     9\nd <- data.frame(\n  x = rep(seq_len(10), 10), #x coord\n  y = rep(seq_len(10), each = 10), #y coord\n  z = seq_len(100) #values\n)\nr <- rast(d, crs = \"EPSG:4326\")\nplot(r)\nr <- rast(\"some-file.tif\")\nwriteRaster(\n  r, \"some-file.tif\", \n  overwrite = TRUE, datatype = \"INT4U\"\n)"},{"path":"rasters.html","id":"raster-manipulation","chapter":"3 Rasters","heading":"3.4 Raster manipulation","text":"Rasters can manipulated way matrix.\nexample:can also add multiply rasters together:","code":"\nr + 10 #add a constant## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :  11 \n## max value   : 110\n2 * r #multiply by a constant## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :   2 \n## max value   : 200\nr ^ 2 #power## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :     z \n## min value   :     1 \n## max value   : 10000\n2 * r + 10 #combined addition and multiplication## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :  12 \n## max value   : 210\nr + r## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   z \n## min value   :   2 \n## max value   : 200\nr * r## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :     z \n## min value   :     1 \n## max value   : 10000"},{"path":"rasters.html","id":"raster-stacks","chapter":"3 Rasters","heading":"3.5 Raster stacks","text":"can also stack rasters create 3D stacks.\nterra, achieved simply appending rasters together:Stacks quite useful can call vectorized functions , e.g.:","code":"\ns <- c(r, -r / 2)\ns## class       : SpatRaster \n## dimensions  : 10, 10, 2  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## names       :   z,     z \n## min values  :   1, -50.0 \n## max values  : 100,  -0.5\nplot(s)\nplot(mean(s)) #mean\nstdev(s)^2 #variance## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :       std \n## min value   :    0.5625 \n## max value   : 5625.0000\nprod(s) #product## class       : SpatRaster \n## dimensions  : 10, 10, 1  (nrow, ncol, nlyr)\n## resolution  : 1, 1  (x, y)\n## extent      : 0.5, 10.5, 0.5, 10.5  (xmin, xmax, ymin, ymax)\n## coord. ref. : lon/lat WGS 84 (EPSG:4326) \n## source(s)   : memory\n## name        :   prod \n## min value   : -5e+03 \n## max value   : -5e-01"},{"path":"rasters.html","id":"example-stacks-for-ecology","chapter":"3 Rasters","heading":"3.6 Example: stacks for ecology","text":"Imagine sampled occurrences 100 species want know number species detected cell.\ndistribution one species saved file species-1.tif may look like :can load :get number species detected cell, simply need sum across stack:","code":"\nr <- rast(\"species-1.tif\")\nplot(r)\nfiles <- list.files(\"data/\", pattern = \"species-\")\ns <- rast(files)\nplot(s[[c(5, 35, 75)]]) #show species 5, 35, and 75\nS <- sum(s)\nplot(S, col = hcl.colors(minmax(S)[\"max\", ] + 1, \"Zissou 1\"))"},{"path":"overview-of-the-data-we-will-use.html","id":"overview-of-the-data-we-will-use","chapter":"4 Overview of the data we will use","heading":"4 Overview of the data we will use","text":"operations staple GIS.\nexample: distance two features? area polygon? value raster specific locations?\nillustrate practical examples, use data can find data/ folder repo https://github.com/emilio-berti/gis-course.data/EU/EU.shp contains polygons countries European Union:data/ISTAT/Limiti01012024_g/Reg01012024_g/Reg01012024_g_WGS84.shp contains polygons regions (administrative division state) Italy:data/ISTAT/Limiti01012024_g/ProvCM01012024_g/ProvCM01012024_g_WGS84.shp contains polygons provinces (administrative division commune region) Italy:data/wc2.1_10m_bio_1.tif mean annual temperature (averaged across several decades) 10 minute resolution WorldClim. cropped Europe (excluding parts Scandinavia save disk space):","code":"\neu <- vect(\"data/EU/EU.shp\")\nplot(eu, col = \"#001489\", border = \"white\", lw = 2)\nreg <- vect(\"data/ISTAT/Limiti01012024_g/Reg01012024_g/Reg01012024_g_WGS84.shp\")\nplot(\n  reg, \"DEN_REG\",\n  col = hcl.colors(length(reg), \"Set 2\")\n)\nitaly <- vect(\"data/ISTAT/Limiti01012024_g/ProvCM01012024_g/ProvCM01012024_g_WGS84.shp\")\nplot(\n  italy, \"DEN_UTS\",\n  col = colors()[sample(seq_along(colors()), length(italy))]\n)\nbio1 <- rast(\"data/wc2.1_10m_bio_1.tif\")\nplot(bio1, col = hcl.colors(100, \"Zissou 1\"))"},{"path":"convert-a-vector-to-a-raster.html","id":"convert-a-vector-to-a-raster","chapter":"5 Convert a vector to a raster","heading":"5 Convert a vector to a raster","text":"terra, vector can converted raster using rasterize(x, y),\nx vector convert raster y template raster metadata re-used x:rasterize() can also take optional argument field, used assign cells values:","code":"\nbio1 <- rast(\"data/wc2.1_10m_bio_1.tif\") #load raster template\neu <- vect(\"data/EU/EU.shp\") #load zone layer\nr_eu <- rasterize(eu, bio1)\nplot(r_eu, col = \"#001489\")\nr_eu <- rasterize(eu, bio1, field = \"NAME_ENGL\")\nplot(r_eu, col = hcl.colors(length(eu), \"Dynamic\"))\nlines(eu)"},{"path":"convert-a-vector-to-a-raster.html","id":"covert-a-raster-to-a-vector","chapter":"5 Convert a vector to a raster","heading":"5.1 Covert a raster to a vector","text":".polygons() can used convert raster vector.\ndefault, new polygon dissolved, .e. vector one geometry value raster; can turned specifying dissolve = FALSE, usually want dissolved.\nMoreover, default behavior .polygons() round rasters many different values, avoid creating many polygons; can turned specifying round = FALSE.\nLet’s look options:","code":"\n#default is round = TRUE an dissolve = TRUE\nlength(as.polygons(bio1, round = FALSE))## [1] 40477\nlength(as.polygons(bio1, dissolve = FALSE))## [1] 40856\nlength(as.polygons(bio1, round = FALSE, dissolve = FALSE))## [1] 40856\nv_bio1 <- as.polygons(bio1) \nlength(v_bio1)## [1] 30\nplot(v_bio1, col = hcl.colors(length(v_bio1), \"Zissou 1\"))"},{"path":"simple-operations-on-vectors.html","id":"simple-operations-on-vectors","chapter":"6 Simple operations on vectors","heading":"6 Simple operations on vectors","text":"","code":""},{"path":"simple-operations-on-vectors.html","id":"perimiter","chapter":"6 Simple operations on vectors","heading":"6.1 Perimiter","text":"perim() used get perimiter vector:(Look Greece islands!)","code":"\neu <- vect(\"data/EU/EU.shp\")\neu[[\"perimeter\"]] <- perim(eu) / 1e3 #in km\nplot(\n  eu, \"perimeter\",\n  type = \"continuous\", \n  col = hcl.colors(length(eu), \"Dark Mint\")\n)"},{"path":"simple-operations-on-vectors.html","id":"area","chapter":"6 Simple operations on vectors","heading":"6.2 Area","text":"expanse() used calculate area vectors:(Sweden smaller looks)Bonus:(call relationship island factor)","code":"\neu[[\"area\"]] <- expanse(eu, unit = \"km\")\nplot(\n  eu, \"area\",\n  type = \"continuous\",\n  col = hcl.colors(length(eu), \"Dark Mint\")\n)\nmapped_islands <- table(disagg(eu)$NAME_ENGL)[eu$NAME_ENGL] #some magic\nwith(as.data.frame(eu), plot(\n  perimeter, area, \n  pch = 20, cex = 2,\n  col = \"dodgerblue3\"\n))\ntext(\n  x = eu$perimeter, y = eu$area,\n  labels = eu$NAME_ENGL, \n  adj = c(0.5, -1),\n)\ntext(\n  x = eu$perimeter, y = eu$area,\n  labels = paste(mapped_islands, \"islands\"),\n  adj = c(0.5, 2),\n)"},{"path":"simple-operations-on-vectors.html","id":"centroids","chapter":"6 Simple operations on vectors","heading":"6.3 Centroids","text":"centroid point defined arithmetic mean position points surface polygon.\ninstance, centroids square polygon ’s center:","code":"\np <- vect(\n  matrix(\n    c(0, 0, 1, 0, 1, 1, 0, 1, 0, 0), byrow = TRUE, ncol = 2\n  )\n)\np <- as.lines(p)\np <- as.polygons(p)\ncentr <- centroids(p)\nplot(p, col = \"dodgerblue\", alpha = .5)\npoints(centr, col = \"tomato\", cex = 3)\np <- vect(matrix(c(0, 0, 1, 0, 1, 1, 0.9, 0.1, 0, 0), byrow = TRUE, ncol = 2))\np <- as.lines(p)\np <- as.polygons(p)\ncentr <- centroids(p)\nplot(p, col = \"dodgerblue\", alpha = .5)\npoints(centr, col = \"tomato\", cex = 3)\neu_centr <- centroids(eu)\neu <- vect(\"data/EU/EU.shp\")\nplot(eu, col = \"#001489\", border = \"white\", lw = 1)\npoints(eu_centr, col = \"#FFDD00\", cex = 2, pch = 3, lw = 2)"},{"path":"simple-operations-on-vectors.html","id":"buffer","chapter":"6 Simple operations on vectors","heading":"6.4 Buffer","text":"buffer polygon extend perimeter directions time, .e. orthogonally tangent line point.\nBuffering achieved terra using buffer(x, width).\neasier see explain .","code":"\nb <- buffer(eu, 1e5) #100km for visualizing it\nplot(eu, col = \"#001489\")\nlines(b, col = \"tomato\", lw = 2)"},{"path":"simple-operations-on-vectors.html","id":"neighbors-of-polygons","chapter":"6 Simple operations on vectors","heading":"6.5 Neighbors of polygons","text":"terra, neighbors polygon obtained using adjacent().\noutput adjacent() matrix, either two columns first IDs \\(n\\) countries \\(n \\times n\\) representing adjacency matrix countries.\nlike adjacency matrix, therefore:(Germany truly hearth EU)","code":"\nneigh <- as.list(rep(NA, length(eu))) #initialize empty list\nnames(neigh) <- eu$NAME_ENGL\nadj <- adjacent(eu, pairs = FALSE)\n\n# then a convoluted code to show the number of neighbors\nfor (i in seq_along(eu)) {\n  ctr <- eu[adj[i, ] == 1, ]\n  if(length(ctr) > 0) {\n    neigh[[i]] <- unique(ctr$NAME_ENGL)\n  } else {\n    neigh[[i]] <- \"No neighbours\"\n  }\n}\neu$neigh <- sapply(neigh, length)\neu$neigh[sapply(neigh, \\(x) all(x == \"No neighbours\"))] <- 0\nplot(\n  eu, \"neigh\", \n  col = hcl.colors(max(eu$neigh) + 1, \"Dark Mint\")\n)"},{"path":"vector-operations.html","id":"vector-operations","chapter":"7 Vector operations","heading":"7 Vector operations","text":"","code":""},{"path":"vector-operations.html","id":"loading-vectors","chapter":"7 Vector operations","heading":"7.1 Loading vectors","text":"Load vector shapefile EU countries:vector contains polygons 27 countries European Union (EU).\nAdditionally, attribute table attached , providing information country name, ISO3 code, etc.\ncan see full list attributes using names(eu):","code":"\neu <- vect(\"data/EU/EU.shp\")\neu##  class       : SpatVector \n##  geometry    : polygons \n##  dimensions  : 27, 11  (geometries, attributes)\n##  extent      : -10.38743, 34.39352, 34.57181, 70.0864  (xmin, xmax, ymin, ymax)\n##  source      : EU.shp\n##  coord. ref. : lon/lat WGS 84 (EPSG:4326) \n##  names       : CNTR_ID NAME_ENGL NAME_FREN ISO3_CODE         SVRG_UN     CAPT\n##  type        :   <chr>     <chr>     <chr>     <chr>           <chr>    <chr>\n##  values      :      AT   Austria  Autriche       AUT UN Member State   Vienna\n##                     BE   Belgium  Belgique       BEL UN Member State Brussels\n##                     BG  Bulgaria  Bulgarie       BGR UN Member State    Sofia\n##  EU_STAT EFTA_STAT CC_STAT  NAME_GERM   FID\n##    <chr>     <chr>   <chr>      <chr> <chr>\n##        T         F       F Österreich    AT\n##        T         F       F    Belgien    BE\n##        T         F       F  Bulgarien    BG\nnames(eu)##  [1] \"CNTR_ID\"   \"NAME_ENGL\" \"NAME_FREN\" \"ISO3_CODE\" \"SVRG_UN\"   \"CAPT\"     \n##  [7] \"EU_STAT\"   \"EFTA_STAT\" \"CC_STAT\"   \"NAME_GERM\" \"FID\""},{"path":"zonal-statistics.html","id":"zonal-statistics","chapter":"8 Zonal statistics","heading":"8 Zonal statistics","text":"Zonal statstics calcualted zones, .e. regions defined either cell value (rasters) polygons (shapefiles).\nZonal calculation implemented terra using zonal().","code":""},{"path":"zonal-statistics.html","id":"zones-as-a-shapefile","chapter":"8 Zonal statistics","heading":"8.1 Zones as a shapefile","text":"zones defined shapefile, e.g. polygons EU, zonal statistics calculated.\nsyntax zonal(x, y, fun),\nx layer values calculate statistics ,\ny layer zones,\nfun function statistic.\nexample, can calculate average value annual temperature coutry see varies latitude:\ncase x raster (usually ), can also geometry.using another fun can obtain statistics.\nexample, can get minimum maximum values country:","code":"\neu <- vect(\"data/EU/EU.shp\") #load zone layer\neu_centr <- centroids(eu) #get centroids\nlat <- geom(eu_centr)[, \"y\"] #get latitude of centroids\n\nbio1 <- rast(\"data/wc2.1_10m_bio_1.tif\") #load temperature layer\n\nbio1_mean <- zonal(bio1, eu, \"mean\") #zonal calculation - mean value\nbio1_mean <- bio1_mean[[1]] #as vector\nplot(\n  lat, bio1_mean,\n  pch = 20, cex = 2, \n  col = \"grey50\",\n  xlab = \"Latitude\",\n  ylab = \"Average temperature\"\n)\nbio1_min <- zonal(bio1, eu, \"min\") #zonal calculation\nbio1_min <- bio1_min[[1]] #as vector\nbio1_max <- zonal(bio1, eu, \"max\") #zonal calculation\nbio1_max <- bio1_max[[1]] #as vector\nplot(\n  lat, bio1_mean,\n  pch = 20, cex = 2, \n  col = \"grey50\",\n  xlab = \"Latitude\",\n  ylab = \"Average temperature\",\n  ylim = c(min(bio1_min), max(bio1_max))\n)\npoints(\n  lat, bio1_min,\n  pch = 6, cex = 2, \n  col = \"dodgerblue3\"\n)\npoints(\n  lat, bio1_max,\n  pch = 2, cex = 2, \n  col = \"tomato\"\n)"},{"path":"mapping.html","id":"mapping","chapter":"9 Mapping","heading":"9 Mapping","text":"One common goal GIS produce map phenomenon process.example, use data Italian National Insitute Statistics (ISTAT):Administrative division shapefile (https://www.istat.//archivio/222527).GDP regions, second administrative division State.data/ISTAT/ folder, respective subdirectories.Load vector shapefile EU countries:","code":"\nlibrary(terra)\n\n# shapefile of regions\nregs <- vect(\"data/ISTAT/Limiti01012024_g/Reg01012024_g/Reg01012024_g_WGS84.shp\")\n\n# shapefile of cities\ncities <- vect(\"data/ISTAT/Limiti01012024_g/Com01012024_g/Com01012024_g_WGS84.shp\")\n\n# noise pollution\nnoise <- read.csv(\"data/ISTAT/city-acoustic-noise.csv\")\nnoise <- noise[noise$TIME_PERIOD == 2012, ] #only 2012\nnoise <- noise[noise$TIME_PERIOD != \"IT\", ] #only city level\nnoise <- noise[noise$TYPE_OF_MONITORING == 1, ] #sensor type\nnoise <- noise[!is.na(noise$OBS_VALUE), ] #remove empty\nnoise <- noise[noise$DATA_TYPE == \"MON_LIM\", ] #monthly limit\n\n# not all cities studies: remove not studied\nstudied <- intersect(cities$PRO_COM_T, noise$REF_AREA)\ncities <- cities[cities$PRO_COM_T %in% studied]\nnoise <- noise[noise$REF_AREA %in% studied, ]\n\n# add attribute\ncities$noise <- noise$OBS_VALUE[sapply(noise$REF_AREA, \\(x) which(cities$PRO_COM_T == x))]\ncities <- cities[order(cities$noise)]\ncities <- cities[cities$noise > 0] #suspect data\n\n# map -----------\nnoise_vals <- unique(cities$noise)\ncolors <- colorRampPalette(c(\"green3\", \"tomato\"))(length(noise_vals))\npal <- c()\nfor ( x in noise_vals ) {\n  pal <- c(pal, rep(colors[which(x == noise_vals)], sum(cities$noise == x)))\n}\n\n#plot(regs)\n#plot(cities, col = as.numeric(cities$noise), add = TRUE)\n\n# regional statistics ----------\nregs$noise <- NA\nregs$noise_cv <- NA\nfor ( i in seq_along(regs) ) {\n  within <- relate(cities, regs[i], \"within\")\n  ids <- which(within, arr.ind = TRUE)[, \"row\"]\n  regs$noise[ids] <- mean(cities$noise[ids])\n  regs$noise_cv[ids] <-  sd(cities$noise[ids]) / mean(cities$noise[ids])\n}\nregs$noise <- as.numeric(regs$noise)\nregs$noise_cv <- as.numeric(regs$noise_cv)\n\nlayout(matrix(c(2, 3, 1, 1), byrow = TRUE, ncol = 2))\npar(mar = c(4, 4, 2, 2))\nscatter.smooth(\n  regs$noise, regs$noise_cv,\n  pch = 20, cex = 2, frame = FALSE,\n  xlab = \"Noise\",\n  ylab = \"Variability (CV)\"\n)\nplot(\n  regs,\n  \"noise\",\n  col = colorRampPalette(c(\"green2\", \"tomato\"))(20),\n  type = \"continuous\",\n  axes = FALSE,\n  main = \"Noise pollution\"\n)\nplot(\n  regs,\n  \"noise_cv\",\n  col = colorRampPalette(c(\"grey90\", \"dodgerblue2\"))(20),\n  type = \"continuous\",\n  axes = FALSE,\n  main = \"Variability (CV)\"\n)"}]
