# Rasters
Because rasters are fundamentally 2D matrices with matadata, it is useful to understand what is a matrix before jumping straight into the topic.
A 2D matrix $A$ is a mathematical object that can be represented as a grid.
The elements $A_{ij}$ of the matrix $A$ are called its entries.
The subscript in $A_{ij}$ indicate the row and column coordinates of the entries.
For example, $A_{1,1}$ is the element in first row and first column, while $A_{3,4}$ is the element in the third row and fourth column.

## Matrices in R
R provides native support for matrices.
In fact, R was designed to work with matrices, as most statistical models can be represented as operation on matrices.

```{r}
vals <- seq_len(9)
A <- matrix(vals, byrow = TRUE, nrow = 3, ncol = 3)
A
```

When `byrow = TRUE`, the values contained in `vals` are inserted into the matrix row-wise, i.e. $A_{1,1}$ = `vals[1]`, $A_{1,2}$ = `vals[2]`, etc.
This argument can be omitted if inserting elements column-wise is preferred; in this case, $A_{2,1}$ = `vals[2]`, etc.
The arguments `ncol` and `nrow` specify the dimension of the matrix.
If you specify only one of the two, R will infer the other dimension.
You can specify both of them and I invite you to do so for clarity and to avoid guessing.

## Rasters
A raster is basically a 2D matrix with associated metadata.
The most important metadata define:

  - The spatial _extent_.
  - The spatial _resolution_. 
  - The coordinate reference system, _crs_.

The extent tells us what is the area covered by the raster, i.e. the coordinates of its four angles.
The resolution specifies how big a cell pixel is.
The CRS defines the projection (if any) of the raster.
A raster without these three metadata is, in most cases, useless.

## Rasters in R
To create a raster using `terra`, you can use the `rast()` function.
You can use as input a matrix.

```{r}
r <- rast(A, crs = "EPSG:4326")
r
```

Or a dataframe.

```{r}
d <- data.frame(
  x = rep(seq_len(10), 10), #x coord
  y = rep(seq_len(10), each = 10), #y coord
  z = seq_len(100) #values
)
r <- rast(d, crs = "EPSG:4326")
plot(r)
```

Let's see also the associated metadata:

```{r rast-meta}
ext(r)  # spatial extent
res(r)  # resolution, i.e. cell pixel size
crs(r, proj = TRUE)  # CRS
```

## Reading and writing rasters

`rast()` is also used to read rasters from files.

```{r, eval=FALSE}
r <- rast(<filename>)
```

To write rasters to files, the `writeRaster()` function is used.

```{r, eval=FALSE}
writeRaster(<spatRast>, <filename>)
```

<!-- The `overwrite` and `datatype` arguments are optional, but I strongly recommend you to always include them.
`overwrite = TRUE` simply make sure that, if the raster already exists on disk, it is overwritten.
_terra_, by defaults, throw an error if the file exists and `overwrite = FALSE`, which can be annoying when working on servers.
`datatype` specifies the numeric type of the matrix elements.
Available types are _signed_ and _unsigned_ _integer_ and _float_.
You also have to specify the number of bytes to use for each entry.
Available dataype choices are:

  - INT1U, unsigned integer of 1 byte: $\in [0, 2^8]$.
  - INT2U, unsigned integer of 2 bytes: $\in [0, 2^{16}]$.
  - INT2S, signed integer of 2 bytes: $\in [-2^8 + 1, 2^8]$. 
  - INT4U, unsigned integer of 4 bytes: $\in [0, 2^{32}]$. 
  - INT4S, signed integer of 4 bytes: $\in [-2^{16} + 1, 2^{16}]$. 
  - FLT4S, signed floating point (real) number of 4 bytes: $\in [1.2 \cdot 10^{-38}, 3.4 \cdot 10^{38}]$
  - FLT8S, signed floating point (real) number of 8 bytes: $\in [2.3 \cdot 10^{-308}, 1.7 \cdot 10^{308}]$
  
You can actually store numbers also outside the range of the numeric types, but this will come to the cost of precision, so you should try to avoid going outside ranges.
This does not mean that you should always save files as _FLT8S_, as this will require more disk space and slow down writing/reading operations.
For example, if you want to store the elevation at global scale with a precision of one meter, _INT2U_ is the optimal choice, as it is the smallest type that can store the information.
 -->

## Raster manipulation
Rasters can be manipulated in the same way you would do with a matrix.
For example:

```{r manipulate-1, eval=FALSE}
r + 10  # add a constant
2 * r  # multiply by a constant
r ^ 2  # power
2 * r + 10  # combined addition and multiplication
```
You can also add and multiply rasters together:
```{r manipulate-2}
r + r
r * r
```

## Raster stacks
You can also stack rasters to create 3D stacks.
In _terra_, this is achieved simply by appending the rasters together:
```{r stack-1}
s <- c(r, -r / 2)
s
plot(s)
```

Stacks are quite useful because you can call vectorized functions on them, e.g.:
```{r stack-2}
plot(mean(s))  # mean
stdev(s)^2  # variance
prod(s)  # product
```

## Example: species richness per cell

Imagine you sampled the occurrences for 100 species and want to know the number of species detected in each cell.
The distribution of one species is saved in the file _species-1.tif_ and may look like this:
```{r, eval=FALSE}
r <- rast("species-1.tif")
plot(r)
```

```{r, echo=FALSE}
sp <- rast(
  matrix(
    sample(c(0, 1), 1e2, replace = TRUE, prob = c(10, 1)),
    1e1, 1e1
  )
)
plot(sp)
```


You can load all of them at once:
```{r, eval = FALSE}
files <- list.files("data/", pattern = "species-")
s <- rast(files)
plot(s[[c(5, 35, 75)]])  # show species 5, 35, and 75
```

```{r, create-raster, echo=FALSE}
for (i in seq_len(100)) {
  sp <- rast(
    matrix(
      sample(c(0, 1), 1e2, replace = TRUE, prob = c(10+i, 1)),
      1e1, 1e1
    )
  )
  writeRaster(sp, paste0("/tmp/species-", i, ".tif"), overwrite = TRUE)
}
s <- rast(paste0("/tmp/species-", seq_len(100), ".tif"))
names(s) <- paste0("species-", seq_len(nlyr(s)))
plot(s[[c(5, 35, 75)]]) #show species 5, 35, and 75
```

To get the number of species detected in each cell, you simply need to sum across the stack:

```{r}
S <- sum(s)
plot(S, col = hcl.colors(minmax(S)["max", ] + 1, "Zissou 1"))
```
